// Code generated by ent, DO NOT EDIT.

package informationv1

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
	"github.com/tikafog/of/dbc/media/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreatedUnix applies equality check predicate on the "created_unix" field. It's identical to CreatedUnixEQ.
func CreatedUnix(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedUnix), v))
	})
}

// UpdatedUnix applies equality check predicate on the "updated_unix" field. It's identical to UpdatedUnixEQ.
func UpdatedUnix(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedUnix), v))
	})
}

// DeletedUnix applies equality check predicate on the "deleted_unix" field. It's identical to DeletedUnixEQ.
func DeletedUnix(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeletedUnix), v))
	})
}

// ChannelID applies equality check predicate on the "channel_id" field. It's identical to ChannelIDEQ.
func ChannelID(v uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldChannelID), v))
	})
}

// Root applies equality check predicate on the "root" field. It's identical to RootEQ.
func Root(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoot), v))
	})
}

// Thumb applies equality check predicate on the "thumb" field. It's identical to ThumbEQ.
func Thumb(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldThumb), v))
	})
}

// ThumbPath applies equality check predicate on the "thumb_path" field. It's identical to ThumbPathEQ.
func ThumbPath(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldThumbPath), v))
	})
}

// Poster applies equality check predicate on the "poster" field. It's identical to PosterEQ.
func Poster(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPoster), v))
	})
}

// PosterPath applies equality check predicate on the "poster_path" field. It's identical to PosterPathEQ.
func PosterPath(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPosterPath), v))
	})
}

// Media applies equality check predicate on the "media" field. It's identical to MediaEQ.
func Media(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMedia), v))
	})
}

// MediaPath applies equality check predicate on the "media_path" field. It's identical to MediaPathEQ.
func MediaPath(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMediaPath), v))
	})
}

// MediaIndex applies equality check predicate on the "media_index" field. It's identical to MediaIndexEQ.
func MediaIndex(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMediaIndex), v))
	})
}

// Frames applies equality check predicate on the "frames" field. It's identical to FramesEQ.
func Frames(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFrames), v))
	})
}

// FramesPath applies equality check predicate on the "frames_path" field. It's identical to FramesPathEQ.
func FramesPath(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFramesPath), v))
	})
}

// Title applies equality check predicate on the "title" field. It's identical to TitleEQ.
func Title(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTitle), v))
	})
}

// VideoNo applies equality check predicate on the "video_no" field. It's identical to VideoNoEQ.
func VideoNo(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVideoNo), v))
	})
}

// Intro applies equality check predicate on the "intro" field. It's identical to IntroEQ.
func Intro(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIntro), v))
	})
}

// Director applies equality check predicate on the "director" field. It's identical to DirectorEQ.
func Director(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDirector), v))
	})
}

// Systematics applies equality check predicate on the "systematics" field. It's identical to SystematicsEQ.
func Systematics(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSystematics), v))
	})
}

// Producer applies equality check predicate on the "producer" field. It's identical to ProducerEQ.
func Producer(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProducer), v))
	})
}

// Publisher applies equality check predicate on the "publisher" field. It's identical to PublisherEQ.
func Publisher(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublisher), v))
	})
}

// SortType applies equality check predicate on the "sort_type" field. It's identical to SortTypeEQ.
func SortType(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSortType), v))
	})
}

// Caption applies equality check predicate on the "caption" field. It's identical to CaptionEQ.
func Caption(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCaption), v))
	})
}

// Group applies equality check predicate on the "group" field. It's identical to GroupEQ.
func Group(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGroup), v))
	})
}

// Index applies equality check predicate on the "index" field. It's identical to IndexEQ.
func Index(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIndex), v))
	})
}

// ReleaseDate applies equality check predicate on the "release_date" field. It's identical to ReleaseDateEQ.
func ReleaseDate(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReleaseDate), v))
	})
}

// Format applies equality check predicate on the "format" field. It's identical to FormatEQ.
func Format(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFormat), v))
	})
}

// Series applies equality check predicate on the "series" field. It's identical to SeriesEQ.
func Series(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSeries), v))
	})
}

// Length applies equality check predicate on the "length" field. It's identical to LengthEQ.
func Length(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLength), v))
	})
}

// Uncensored applies equality check predicate on the "uncensored" field. It's identical to UncensoredEQ.
func Uncensored(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUncensored), v))
	})
}

// Season applies equality check predicate on the "season" field. It's identical to SeasonEQ.
func Season(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSeason), v))
	})
}

// TotalEpisode applies equality check predicate on the "total_episode" field. It's identical to TotalEpisodeEQ.
func TotalEpisode(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalEpisode), v))
	})
}

// Episode applies equality check predicate on the "episode" field. It's identical to EpisodeEQ.
func Episode(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEpisode), v))
	})
}

// Language applies equality check predicate on the "language" field. It's identical to LanguageEQ.
func Language(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLanguage), v))
	})
}

// Sharpness applies equality check predicate on the "sharpness" field. It's identical to SharpnessEQ.
func Sharpness(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSharpness), v))
	})
}

// Watermark applies equality check predicate on the "watermark" field. It's identical to WatermarkEQ.
func Watermark(v bool) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWatermark), v))
	})
}

// Sign applies equality check predicate on the "sign" field. It's identical to SignEQ.
func Sign(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSign), v))
	})
}

// TotalBlocks applies equality check predicate on the "total_blocks" field. It's identical to TotalBlocksEQ.
func TotalBlocks(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalBlocks), v))
	})
}

// CreatedUnixEQ applies the EQ predicate on the "created_unix" field.
func CreatedUnixEQ(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedUnix), v))
	})
}

// CreatedUnixNEQ applies the NEQ predicate on the "created_unix" field.
func CreatedUnixNEQ(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedUnix), v))
	})
}

// CreatedUnixIn applies the In predicate on the "created_unix" field.
func CreatedUnixIn(vs ...int64) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedUnix), v...))
	})
}

// CreatedUnixNotIn applies the NotIn predicate on the "created_unix" field.
func CreatedUnixNotIn(vs ...int64) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedUnix), v...))
	})
}

// CreatedUnixGT applies the GT predicate on the "created_unix" field.
func CreatedUnixGT(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedUnix), v))
	})
}

// CreatedUnixGTE applies the GTE predicate on the "created_unix" field.
func CreatedUnixGTE(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedUnix), v))
	})
}

// CreatedUnixLT applies the LT predicate on the "created_unix" field.
func CreatedUnixLT(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedUnix), v))
	})
}

// CreatedUnixLTE applies the LTE predicate on the "created_unix" field.
func CreatedUnixLTE(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedUnix), v))
	})
}

// UpdatedUnixEQ applies the EQ predicate on the "updated_unix" field.
func UpdatedUnixEQ(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedUnix), v))
	})
}

// UpdatedUnixNEQ applies the NEQ predicate on the "updated_unix" field.
func UpdatedUnixNEQ(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedUnix), v))
	})
}

// UpdatedUnixIn applies the In predicate on the "updated_unix" field.
func UpdatedUnixIn(vs ...int64) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedUnix), v...))
	})
}

// UpdatedUnixNotIn applies the NotIn predicate on the "updated_unix" field.
func UpdatedUnixNotIn(vs ...int64) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedUnix), v...))
	})
}

// UpdatedUnixGT applies the GT predicate on the "updated_unix" field.
func UpdatedUnixGT(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedUnix), v))
	})
}

// UpdatedUnixGTE applies the GTE predicate on the "updated_unix" field.
func UpdatedUnixGTE(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedUnix), v))
	})
}

// UpdatedUnixLT applies the LT predicate on the "updated_unix" field.
func UpdatedUnixLT(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedUnix), v))
	})
}

// UpdatedUnixLTE applies the LTE predicate on the "updated_unix" field.
func UpdatedUnixLTE(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedUnix), v))
	})
}

// DeletedUnixEQ applies the EQ predicate on the "deleted_unix" field.
func DeletedUnixEQ(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeletedUnix), v))
	})
}

// DeletedUnixNEQ applies the NEQ predicate on the "deleted_unix" field.
func DeletedUnixNEQ(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDeletedUnix), v))
	})
}

// DeletedUnixIn applies the In predicate on the "deleted_unix" field.
func DeletedUnixIn(vs ...int64) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDeletedUnix), v...))
	})
}

// DeletedUnixNotIn applies the NotIn predicate on the "deleted_unix" field.
func DeletedUnixNotIn(vs ...int64) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDeletedUnix), v...))
	})
}

// DeletedUnixGT applies the GT predicate on the "deleted_unix" field.
func DeletedUnixGT(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDeletedUnix), v))
	})
}

// DeletedUnixGTE applies the GTE predicate on the "deleted_unix" field.
func DeletedUnixGTE(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDeletedUnix), v))
	})
}

// DeletedUnixLT applies the LT predicate on the "deleted_unix" field.
func DeletedUnixLT(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDeletedUnix), v))
	})
}

// DeletedUnixLTE applies the LTE predicate on the "deleted_unix" field.
func DeletedUnixLTE(v int64) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDeletedUnix), v))
	})
}

// DeletedUnixIsNil applies the IsNil predicate on the "deleted_unix" field.
func DeletedUnixIsNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDeletedUnix)))
	})
}

// DeletedUnixNotNil applies the NotNil predicate on the "deleted_unix" field.
func DeletedUnixNotNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDeletedUnix)))
	})
}

// ChannelIDEQ applies the EQ predicate on the "channel_id" field.
func ChannelIDEQ(v uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldChannelID), v))
	})
}

// ChannelIDNEQ applies the NEQ predicate on the "channel_id" field.
func ChannelIDNEQ(v uuid.UUID) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldChannelID), v))
	})
}

// ChannelIDIn applies the In predicate on the "channel_id" field.
func ChannelIDIn(vs ...uuid.UUID) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldChannelID), v...))
	})
}

// ChannelIDNotIn applies the NotIn predicate on the "channel_id" field.
func ChannelIDNotIn(vs ...uuid.UUID) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldChannelID), v...))
	})
}

// ChannelIDIsNil applies the IsNil predicate on the "channel_id" field.
func ChannelIDIsNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldChannelID)))
	})
}

// ChannelIDNotNil applies the NotNil predicate on the "channel_id" field.
func ChannelIDNotNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldChannelID)))
	})
}

// RootEQ applies the EQ predicate on the "root" field.
func RootEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoot), v))
	})
}

// RootNEQ applies the NEQ predicate on the "root" field.
func RootNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRoot), v))
	})
}

// RootIn applies the In predicate on the "root" field.
func RootIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRoot), v...))
	})
}

// RootNotIn applies the NotIn predicate on the "root" field.
func RootNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRoot), v...))
	})
}

// RootGT applies the GT predicate on the "root" field.
func RootGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRoot), v))
	})
}

// RootGTE applies the GTE predicate on the "root" field.
func RootGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRoot), v))
	})
}

// RootLT applies the LT predicate on the "root" field.
func RootLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRoot), v))
	})
}

// RootLTE applies the LTE predicate on the "root" field.
func RootLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRoot), v))
	})
}

// RootContains applies the Contains predicate on the "root" field.
func RootContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRoot), v))
	})
}

// RootHasPrefix applies the HasPrefix predicate on the "root" field.
func RootHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRoot), v))
	})
}

// RootHasSuffix applies the HasSuffix predicate on the "root" field.
func RootHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRoot), v))
	})
}

// RootEqualFold applies the EqualFold predicate on the "root" field.
func RootEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRoot), v))
	})
}

// RootContainsFold applies the ContainsFold predicate on the "root" field.
func RootContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRoot), v))
	})
}

// ThumbEQ applies the EQ predicate on the "thumb" field.
func ThumbEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldThumb), v))
	})
}

// ThumbNEQ applies the NEQ predicate on the "thumb" field.
func ThumbNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldThumb), v))
	})
}

// ThumbIn applies the In predicate on the "thumb" field.
func ThumbIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldThumb), v...))
	})
}

// ThumbNotIn applies the NotIn predicate on the "thumb" field.
func ThumbNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldThumb), v...))
	})
}

// ThumbGT applies the GT predicate on the "thumb" field.
func ThumbGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldThumb), v))
	})
}

// ThumbGTE applies the GTE predicate on the "thumb" field.
func ThumbGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldThumb), v))
	})
}

// ThumbLT applies the LT predicate on the "thumb" field.
func ThumbLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldThumb), v))
	})
}

// ThumbLTE applies the LTE predicate on the "thumb" field.
func ThumbLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldThumb), v))
	})
}

// ThumbContains applies the Contains predicate on the "thumb" field.
func ThumbContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldThumb), v))
	})
}

// ThumbHasPrefix applies the HasPrefix predicate on the "thumb" field.
func ThumbHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldThumb), v))
	})
}

// ThumbHasSuffix applies the HasSuffix predicate on the "thumb" field.
func ThumbHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldThumb), v))
	})
}

// ThumbEqualFold applies the EqualFold predicate on the "thumb" field.
func ThumbEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldThumb), v))
	})
}

// ThumbContainsFold applies the ContainsFold predicate on the "thumb" field.
func ThumbContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldThumb), v))
	})
}

// ThumbPathEQ applies the EQ predicate on the "thumb_path" field.
func ThumbPathEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldThumbPath), v))
	})
}

// ThumbPathNEQ applies the NEQ predicate on the "thumb_path" field.
func ThumbPathNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldThumbPath), v))
	})
}

// ThumbPathIn applies the In predicate on the "thumb_path" field.
func ThumbPathIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldThumbPath), v...))
	})
}

// ThumbPathNotIn applies the NotIn predicate on the "thumb_path" field.
func ThumbPathNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldThumbPath), v...))
	})
}

// ThumbPathGT applies the GT predicate on the "thumb_path" field.
func ThumbPathGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldThumbPath), v))
	})
}

// ThumbPathGTE applies the GTE predicate on the "thumb_path" field.
func ThumbPathGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldThumbPath), v))
	})
}

// ThumbPathLT applies the LT predicate on the "thumb_path" field.
func ThumbPathLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldThumbPath), v))
	})
}

// ThumbPathLTE applies the LTE predicate on the "thumb_path" field.
func ThumbPathLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldThumbPath), v))
	})
}

// ThumbPathContains applies the Contains predicate on the "thumb_path" field.
func ThumbPathContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldThumbPath), v))
	})
}

// ThumbPathHasPrefix applies the HasPrefix predicate on the "thumb_path" field.
func ThumbPathHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldThumbPath), v))
	})
}

// ThumbPathHasSuffix applies the HasSuffix predicate on the "thumb_path" field.
func ThumbPathHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldThumbPath), v))
	})
}

// ThumbPathEqualFold applies the EqualFold predicate on the "thumb_path" field.
func ThumbPathEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldThumbPath), v))
	})
}

// ThumbPathContainsFold applies the ContainsFold predicate on the "thumb_path" field.
func ThumbPathContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldThumbPath), v))
	})
}

// PosterEQ applies the EQ predicate on the "poster" field.
func PosterEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPoster), v))
	})
}

// PosterNEQ applies the NEQ predicate on the "poster" field.
func PosterNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPoster), v))
	})
}

// PosterIn applies the In predicate on the "poster" field.
func PosterIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPoster), v...))
	})
}

// PosterNotIn applies the NotIn predicate on the "poster" field.
func PosterNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPoster), v...))
	})
}

// PosterGT applies the GT predicate on the "poster" field.
func PosterGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPoster), v))
	})
}

// PosterGTE applies the GTE predicate on the "poster" field.
func PosterGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPoster), v))
	})
}

// PosterLT applies the LT predicate on the "poster" field.
func PosterLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPoster), v))
	})
}

// PosterLTE applies the LTE predicate on the "poster" field.
func PosterLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPoster), v))
	})
}

// PosterContains applies the Contains predicate on the "poster" field.
func PosterContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPoster), v))
	})
}

// PosterHasPrefix applies the HasPrefix predicate on the "poster" field.
func PosterHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPoster), v))
	})
}

// PosterHasSuffix applies the HasSuffix predicate on the "poster" field.
func PosterHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPoster), v))
	})
}

// PosterEqualFold applies the EqualFold predicate on the "poster" field.
func PosterEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPoster), v))
	})
}

// PosterContainsFold applies the ContainsFold predicate on the "poster" field.
func PosterContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPoster), v))
	})
}

// PosterPathEQ applies the EQ predicate on the "poster_path" field.
func PosterPathEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPosterPath), v))
	})
}

// PosterPathNEQ applies the NEQ predicate on the "poster_path" field.
func PosterPathNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPosterPath), v))
	})
}

// PosterPathIn applies the In predicate on the "poster_path" field.
func PosterPathIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPosterPath), v...))
	})
}

// PosterPathNotIn applies the NotIn predicate on the "poster_path" field.
func PosterPathNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPosterPath), v...))
	})
}

// PosterPathGT applies the GT predicate on the "poster_path" field.
func PosterPathGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPosterPath), v))
	})
}

// PosterPathGTE applies the GTE predicate on the "poster_path" field.
func PosterPathGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPosterPath), v))
	})
}

// PosterPathLT applies the LT predicate on the "poster_path" field.
func PosterPathLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPosterPath), v))
	})
}

// PosterPathLTE applies the LTE predicate on the "poster_path" field.
func PosterPathLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPosterPath), v))
	})
}

// PosterPathContains applies the Contains predicate on the "poster_path" field.
func PosterPathContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPosterPath), v))
	})
}

// PosterPathHasPrefix applies the HasPrefix predicate on the "poster_path" field.
func PosterPathHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPosterPath), v))
	})
}

// PosterPathHasSuffix applies the HasSuffix predicate on the "poster_path" field.
func PosterPathHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPosterPath), v))
	})
}

// PosterPathEqualFold applies the EqualFold predicate on the "poster_path" field.
func PosterPathEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPosterPath), v))
	})
}

// PosterPathContainsFold applies the ContainsFold predicate on the "poster_path" field.
func PosterPathContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPosterPath), v))
	})
}

// MediaEQ applies the EQ predicate on the "media" field.
func MediaEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMedia), v))
	})
}

// MediaNEQ applies the NEQ predicate on the "media" field.
func MediaNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMedia), v))
	})
}

// MediaIn applies the In predicate on the "media" field.
func MediaIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMedia), v...))
	})
}

// MediaNotIn applies the NotIn predicate on the "media" field.
func MediaNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMedia), v...))
	})
}

// MediaGT applies the GT predicate on the "media" field.
func MediaGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMedia), v))
	})
}

// MediaGTE applies the GTE predicate on the "media" field.
func MediaGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMedia), v))
	})
}

// MediaLT applies the LT predicate on the "media" field.
func MediaLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMedia), v))
	})
}

// MediaLTE applies the LTE predicate on the "media" field.
func MediaLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMedia), v))
	})
}

// MediaContains applies the Contains predicate on the "media" field.
func MediaContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMedia), v))
	})
}

// MediaHasPrefix applies the HasPrefix predicate on the "media" field.
func MediaHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMedia), v))
	})
}

// MediaHasSuffix applies the HasSuffix predicate on the "media" field.
func MediaHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMedia), v))
	})
}

// MediaEqualFold applies the EqualFold predicate on the "media" field.
func MediaEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMedia), v))
	})
}

// MediaContainsFold applies the ContainsFold predicate on the "media" field.
func MediaContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMedia), v))
	})
}

// MediaPathEQ applies the EQ predicate on the "media_path" field.
func MediaPathEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMediaPath), v))
	})
}

// MediaPathNEQ applies the NEQ predicate on the "media_path" field.
func MediaPathNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMediaPath), v))
	})
}

// MediaPathIn applies the In predicate on the "media_path" field.
func MediaPathIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMediaPath), v...))
	})
}

// MediaPathNotIn applies the NotIn predicate on the "media_path" field.
func MediaPathNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMediaPath), v...))
	})
}

// MediaPathGT applies the GT predicate on the "media_path" field.
func MediaPathGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMediaPath), v))
	})
}

// MediaPathGTE applies the GTE predicate on the "media_path" field.
func MediaPathGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMediaPath), v))
	})
}

// MediaPathLT applies the LT predicate on the "media_path" field.
func MediaPathLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMediaPath), v))
	})
}

// MediaPathLTE applies the LTE predicate on the "media_path" field.
func MediaPathLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMediaPath), v))
	})
}

// MediaPathContains applies the Contains predicate on the "media_path" field.
func MediaPathContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMediaPath), v))
	})
}

// MediaPathHasPrefix applies the HasPrefix predicate on the "media_path" field.
func MediaPathHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMediaPath), v))
	})
}

// MediaPathHasSuffix applies the HasSuffix predicate on the "media_path" field.
func MediaPathHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMediaPath), v))
	})
}

// MediaPathEqualFold applies the EqualFold predicate on the "media_path" field.
func MediaPathEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMediaPath), v))
	})
}

// MediaPathContainsFold applies the ContainsFold predicate on the "media_path" field.
func MediaPathContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMediaPath), v))
	})
}

// MediaIndexEQ applies the EQ predicate on the "media_index" field.
func MediaIndexEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexNEQ applies the NEQ predicate on the "media_index" field.
func MediaIndexNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexIn applies the In predicate on the "media_index" field.
func MediaIndexIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMediaIndex), v...))
	})
}

// MediaIndexNotIn applies the NotIn predicate on the "media_index" field.
func MediaIndexNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMediaIndex), v...))
	})
}

// MediaIndexGT applies the GT predicate on the "media_index" field.
func MediaIndexGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexGTE applies the GTE predicate on the "media_index" field.
func MediaIndexGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexLT applies the LT predicate on the "media_index" field.
func MediaIndexLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexLTE applies the LTE predicate on the "media_index" field.
func MediaIndexLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexContains applies the Contains predicate on the "media_index" field.
func MediaIndexContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexHasPrefix applies the HasPrefix predicate on the "media_index" field.
func MediaIndexHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexHasSuffix applies the HasSuffix predicate on the "media_index" field.
func MediaIndexHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexEqualFold applies the EqualFold predicate on the "media_index" field.
func MediaIndexEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMediaIndex), v))
	})
}

// MediaIndexContainsFold applies the ContainsFold predicate on the "media_index" field.
func MediaIndexContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMediaIndex), v))
	})
}

// FramesEQ applies the EQ predicate on the "frames" field.
func FramesEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFrames), v))
	})
}

// FramesNEQ applies the NEQ predicate on the "frames" field.
func FramesNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFrames), v))
	})
}

// FramesIn applies the In predicate on the "frames" field.
func FramesIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFrames), v...))
	})
}

// FramesNotIn applies the NotIn predicate on the "frames" field.
func FramesNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFrames), v...))
	})
}

// FramesGT applies the GT predicate on the "frames" field.
func FramesGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFrames), v))
	})
}

// FramesGTE applies the GTE predicate on the "frames" field.
func FramesGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFrames), v))
	})
}

// FramesLT applies the LT predicate on the "frames" field.
func FramesLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFrames), v))
	})
}

// FramesLTE applies the LTE predicate on the "frames" field.
func FramesLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFrames), v))
	})
}

// FramesContains applies the Contains predicate on the "frames" field.
func FramesContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFrames), v))
	})
}

// FramesHasPrefix applies the HasPrefix predicate on the "frames" field.
func FramesHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFrames), v))
	})
}

// FramesHasSuffix applies the HasSuffix predicate on the "frames" field.
func FramesHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFrames), v))
	})
}

// FramesEqualFold applies the EqualFold predicate on the "frames" field.
func FramesEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFrames), v))
	})
}

// FramesContainsFold applies the ContainsFold predicate on the "frames" field.
func FramesContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFrames), v))
	})
}

// FramesPathEQ applies the EQ predicate on the "frames_path" field.
func FramesPathEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFramesPath), v))
	})
}

// FramesPathNEQ applies the NEQ predicate on the "frames_path" field.
func FramesPathNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFramesPath), v))
	})
}

// FramesPathIn applies the In predicate on the "frames_path" field.
func FramesPathIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFramesPath), v...))
	})
}

// FramesPathNotIn applies the NotIn predicate on the "frames_path" field.
func FramesPathNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFramesPath), v...))
	})
}

// FramesPathGT applies the GT predicate on the "frames_path" field.
func FramesPathGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFramesPath), v))
	})
}

// FramesPathGTE applies the GTE predicate on the "frames_path" field.
func FramesPathGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFramesPath), v))
	})
}

// FramesPathLT applies the LT predicate on the "frames_path" field.
func FramesPathLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFramesPath), v))
	})
}

// FramesPathLTE applies the LTE predicate on the "frames_path" field.
func FramesPathLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFramesPath), v))
	})
}

// FramesPathContains applies the Contains predicate on the "frames_path" field.
func FramesPathContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFramesPath), v))
	})
}

// FramesPathHasPrefix applies the HasPrefix predicate on the "frames_path" field.
func FramesPathHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFramesPath), v))
	})
}

// FramesPathHasSuffix applies the HasSuffix predicate on the "frames_path" field.
func FramesPathHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFramesPath), v))
	})
}

// FramesPathEqualFold applies the EqualFold predicate on the "frames_path" field.
func FramesPathEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFramesPath), v))
	})
}

// FramesPathContainsFold applies the ContainsFold predicate on the "frames_path" field.
func FramesPathContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFramesPath), v))
	})
}

// FramesParticularsIsNil applies the IsNil predicate on the "frames_particulars" field.
func FramesParticularsIsNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFramesParticulars)))
	})
}

// FramesParticularsNotNil applies the NotNil predicate on the "frames_particulars" field.
func FramesParticularsNotNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFramesParticulars)))
	})
}

// TitleEQ applies the EQ predicate on the "title" field.
func TitleEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTitle), v))
	})
}

// TitleNEQ applies the NEQ predicate on the "title" field.
func TitleNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTitle), v))
	})
}

// TitleIn applies the In predicate on the "title" field.
func TitleIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTitle), v...))
	})
}

// TitleNotIn applies the NotIn predicate on the "title" field.
func TitleNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTitle), v...))
	})
}

// TitleGT applies the GT predicate on the "title" field.
func TitleGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTitle), v))
	})
}

// TitleGTE applies the GTE predicate on the "title" field.
func TitleGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTitle), v))
	})
}

// TitleLT applies the LT predicate on the "title" field.
func TitleLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTitle), v))
	})
}

// TitleLTE applies the LTE predicate on the "title" field.
func TitleLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTitle), v))
	})
}

// TitleContains applies the Contains predicate on the "title" field.
func TitleContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTitle), v))
	})
}

// TitleHasPrefix applies the HasPrefix predicate on the "title" field.
func TitleHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTitle), v))
	})
}

// TitleHasSuffix applies the HasSuffix predicate on the "title" field.
func TitleHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTitle), v))
	})
}

// TitleEqualFold applies the EqualFold predicate on the "title" field.
func TitleEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTitle), v))
	})
}

// TitleContainsFold applies the ContainsFold predicate on the "title" field.
func TitleContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTitle), v))
	})
}

// VideoNoEQ applies the EQ predicate on the "video_no" field.
func VideoNoEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVideoNo), v))
	})
}

// VideoNoNEQ applies the NEQ predicate on the "video_no" field.
func VideoNoNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldVideoNo), v))
	})
}

// VideoNoIn applies the In predicate on the "video_no" field.
func VideoNoIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldVideoNo), v...))
	})
}

// VideoNoNotIn applies the NotIn predicate on the "video_no" field.
func VideoNoNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldVideoNo), v...))
	})
}

// VideoNoGT applies the GT predicate on the "video_no" field.
func VideoNoGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldVideoNo), v))
	})
}

// VideoNoGTE applies the GTE predicate on the "video_no" field.
func VideoNoGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldVideoNo), v))
	})
}

// VideoNoLT applies the LT predicate on the "video_no" field.
func VideoNoLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldVideoNo), v))
	})
}

// VideoNoLTE applies the LTE predicate on the "video_no" field.
func VideoNoLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldVideoNo), v))
	})
}

// VideoNoContains applies the Contains predicate on the "video_no" field.
func VideoNoContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldVideoNo), v))
	})
}

// VideoNoHasPrefix applies the HasPrefix predicate on the "video_no" field.
func VideoNoHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldVideoNo), v))
	})
}

// VideoNoHasSuffix applies the HasSuffix predicate on the "video_no" field.
func VideoNoHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldVideoNo), v))
	})
}

// VideoNoEqualFold applies the EqualFold predicate on the "video_no" field.
func VideoNoEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldVideoNo), v))
	})
}

// VideoNoContainsFold applies the ContainsFold predicate on the "video_no" field.
func VideoNoContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldVideoNo), v))
	})
}

// IntroEQ applies the EQ predicate on the "intro" field.
func IntroEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIntro), v))
	})
}

// IntroNEQ applies the NEQ predicate on the "intro" field.
func IntroNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIntro), v))
	})
}

// IntroIn applies the In predicate on the "intro" field.
func IntroIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIntro), v...))
	})
}

// IntroNotIn applies the NotIn predicate on the "intro" field.
func IntroNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIntro), v...))
	})
}

// IntroGT applies the GT predicate on the "intro" field.
func IntroGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIntro), v))
	})
}

// IntroGTE applies the GTE predicate on the "intro" field.
func IntroGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIntro), v))
	})
}

// IntroLT applies the LT predicate on the "intro" field.
func IntroLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIntro), v))
	})
}

// IntroLTE applies the LTE predicate on the "intro" field.
func IntroLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIntro), v))
	})
}

// IntroContains applies the Contains predicate on the "intro" field.
func IntroContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldIntro), v))
	})
}

// IntroHasPrefix applies the HasPrefix predicate on the "intro" field.
func IntroHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldIntro), v))
	})
}

// IntroHasSuffix applies the HasSuffix predicate on the "intro" field.
func IntroHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldIntro), v))
	})
}

// IntroEqualFold applies the EqualFold predicate on the "intro" field.
func IntroEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldIntro), v))
	})
}

// IntroContainsFold applies the ContainsFold predicate on the "intro" field.
func IntroContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldIntro), v))
	})
}

// DirectorEQ applies the EQ predicate on the "director" field.
func DirectorEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDirector), v))
	})
}

// DirectorNEQ applies the NEQ predicate on the "director" field.
func DirectorNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDirector), v))
	})
}

// DirectorIn applies the In predicate on the "director" field.
func DirectorIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDirector), v...))
	})
}

// DirectorNotIn applies the NotIn predicate on the "director" field.
func DirectorNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDirector), v...))
	})
}

// DirectorGT applies the GT predicate on the "director" field.
func DirectorGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDirector), v))
	})
}

// DirectorGTE applies the GTE predicate on the "director" field.
func DirectorGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDirector), v))
	})
}

// DirectorLT applies the LT predicate on the "director" field.
func DirectorLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDirector), v))
	})
}

// DirectorLTE applies the LTE predicate on the "director" field.
func DirectorLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDirector), v))
	})
}

// DirectorContains applies the Contains predicate on the "director" field.
func DirectorContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDirector), v))
	})
}

// DirectorHasPrefix applies the HasPrefix predicate on the "director" field.
func DirectorHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDirector), v))
	})
}

// DirectorHasSuffix applies the HasSuffix predicate on the "director" field.
func DirectorHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDirector), v))
	})
}

// DirectorEqualFold applies the EqualFold predicate on the "director" field.
func DirectorEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDirector), v))
	})
}

// DirectorContainsFold applies the ContainsFold predicate on the "director" field.
func DirectorContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDirector), v))
	})
}

// SystematicsEQ applies the EQ predicate on the "systematics" field.
func SystematicsEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSystematics), v))
	})
}

// SystematicsNEQ applies the NEQ predicate on the "systematics" field.
func SystematicsNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSystematics), v))
	})
}

// SystematicsIn applies the In predicate on the "systematics" field.
func SystematicsIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSystematics), v...))
	})
}

// SystematicsNotIn applies the NotIn predicate on the "systematics" field.
func SystematicsNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSystematics), v...))
	})
}

// SystematicsGT applies the GT predicate on the "systematics" field.
func SystematicsGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSystematics), v))
	})
}

// SystematicsGTE applies the GTE predicate on the "systematics" field.
func SystematicsGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSystematics), v))
	})
}

// SystematicsLT applies the LT predicate on the "systematics" field.
func SystematicsLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSystematics), v))
	})
}

// SystematicsLTE applies the LTE predicate on the "systematics" field.
func SystematicsLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSystematics), v))
	})
}

// SystematicsContains applies the Contains predicate on the "systematics" field.
func SystematicsContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSystematics), v))
	})
}

// SystematicsHasPrefix applies the HasPrefix predicate on the "systematics" field.
func SystematicsHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSystematics), v))
	})
}

// SystematicsHasSuffix applies the HasSuffix predicate on the "systematics" field.
func SystematicsHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSystematics), v))
	})
}

// SystematicsEqualFold applies the EqualFold predicate on the "systematics" field.
func SystematicsEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSystematics), v))
	})
}

// SystematicsContainsFold applies the ContainsFold predicate on the "systematics" field.
func SystematicsContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSystematics), v))
	})
}

// ProducerEQ applies the EQ predicate on the "producer" field.
func ProducerEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProducer), v))
	})
}

// ProducerNEQ applies the NEQ predicate on the "producer" field.
func ProducerNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldProducer), v))
	})
}

// ProducerIn applies the In predicate on the "producer" field.
func ProducerIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldProducer), v...))
	})
}

// ProducerNotIn applies the NotIn predicate on the "producer" field.
func ProducerNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldProducer), v...))
	})
}

// ProducerGT applies the GT predicate on the "producer" field.
func ProducerGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldProducer), v))
	})
}

// ProducerGTE applies the GTE predicate on the "producer" field.
func ProducerGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldProducer), v))
	})
}

// ProducerLT applies the LT predicate on the "producer" field.
func ProducerLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldProducer), v))
	})
}

// ProducerLTE applies the LTE predicate on the "producer" field.
func ProducerLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldProducer), v))
	})
}

// ProducerContains applies the Contains predicate on the "producer" field.
func ProducerContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldProducer), v))
	})
}

// ProducerHasPrefix applies the HasPrefix predicate on the "producer" field.
func ProducerHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldProducer), v))
	})
}

// ProducerHasSuffix applies the HasSuffix predicate on the "producer" field.
func ProducerHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldProducer), v))
	})
}

// ProducerEqualFold applies the EqualFold predicate on the "producer" field.
func ProducerEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldProducer), v))
	})
}

// ProducerContainsFold applies the ContainsFold predicate on the "producer" field.
func ProducerContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldProducer), v))
	})
}

// PublisherEQ applies the EQ predicate on the "publisher" field.
func PublisherEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublisher), v))
	})
}

// PublisherNEQ applies the NEQ predicate on the "publisher" field.
func PublisherNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPublisher), v))
	})
}

// PublisherIn applies the In predicate on the "publisher" field.
func PublisherIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPublisher), v...))
	})
}

// PublisherNotIn applies the NotIn predicate on the "publisher" field.
func PublisherNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPublisher), v...))
	})
}

// PublisherGT applies the GT predicate on the "publisher" field.
func PublisherGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPublisher), v))
	})
}

// PublisherGTE applies the GTE predicate on the "publisher" field.
func PublisherGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPublisher), v))
	})
}

// PublisherLT applies the LT predicate on the "publisher" field.
func PublisherLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPublisher), v))
	})
}

// PublisherLTE applies the LTE predicate on the "publisher" field.
func PublisherLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPublisher), v))
	})
}

// PublisherContains applies the Contains predicate on the "publisher" field.
func PublisherContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPublisher), v))
	})
}

// PublisherHasPrefix applies the HasPrefix predicate on the "publisher" field.
func PublisherHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPublisher), v))
	})
}

// PublisherHasSuffix applies the HasSuffix predicate on the "publisher" field.
func PublisherHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPublisher), v))
	})
}

// PublisherEqualFold applies the EqualFold predicate on the "publisher" field.
func PublisherEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPublisher), v))
	})
}

// PublisherContainsFold applies the ContainsFold predicate on the "publisher" field.
func PublisherContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPublisher), v))
	})
}

// SortTypeEQ applies the EQ predicate on the "sort_type" field.
func SortTypeEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSortType), v))
	})
}

// SortTypeNEQ applies the NEQ predicate on the "sort_type" field.
func SortTypeNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSortType), v))
	})
}

// SortTypeIn applies the In predicate on the "sort_type" field.
func SortTypeIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSortType), v...))
	})
}

// SortTypeNotIn applies the NotIn predicate on the "sort_type" field.
func SortTypeNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSortType), v...))
	})
}

// SortTypeGT applies the GT predicate on the "sort_type" field.
func SortTypeGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSortType), v))
	})
}

// SortTypeGTE applies the GTE predicate on the "sort_type" field.
func SortTypeGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSortType), v))
	})
}

// SortTypeLT applies the LT predicate on the "sort_type" field.
func SortTypeLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSortType), v))
	})
}

// SortTypeLTE applies the LTE predicate on the "sort_type" field.
func SortTypeLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSortType), v))
	})
}

// SortTypeContains applies the Contains predicate on the "sort_type" field.
func SortTypeContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSortType), v))
	})
}

// SortTypeHasPrefix applies the HasPrefix predicate on the "sort_type" field.
func SortTypeHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSortType), v))
	})
}

// SortTypeHasSuffix applies the HasSuffix predicate on the "sort_type" field.
func SortTypeHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSortType), v))
	})
}

// SortTypeEqualFold applies the EqualFold predicate on the "sort_type" field.
func SortTypeEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSortType), v))
	})
}

// SortTypeContainsFold applies the ContainsFold predicate on the "sort_type" field.
func SortTypeContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSortType), v))
	})
}

// CaptionEQ applies the EQ predicate on the "caption" field.
func CaptionEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCaption), v))
	})
}

// CaptionNEQ applies the NEQ predicate on the "caption" field.
func CaptionNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCaption), v))
	})
}

// CaptionIn applies the In predicate on the "caption" field.
func CaptionIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCaption), v...))
	})
}

// CaptionNotIn applies the NotIn predicate on the "caption" field.
func CaptionNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCaption), v...))
	})
}

// CaptionGT applies the GT predicate on the "caption" field.
func CaptionGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCaption), v))
	})
}

// CaptionGTE applies the GTE predicate on the "caption" field.
func CaptionGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCaption), v))
	})
}

// CaptionLT applies the LT predicate on the "caption" field.
func CaptionLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCaption), v))
	})
}

// CaptionLTE applies the LTE predicate on the "caption" field.
func CaptionLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCaption), v))
	})
}

// CaptionContains applies the Contains predicate on the "caption" field.
func CaptionContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCaption), v))
	})
}

// CaptionHasPrefix applies the HasPrefix predicate on the "caption" field.
func CaptionHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCaption), v))
	})
}

// CaptionHasSuffix applies the HasSuffix predicate on the "caption" field.
func CaptionHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCaption), v))
	})
}

// CaptionEqualFold applies the EqualFold predicate on the "caption" field.
func CaptionEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCaption), v))
	})
}

// CaptionContainsFold applies the ContainsFold predicate on the "caption" field.
func CaptionContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCaption), v))
	})
}

// GroupEQ applies the EQ predicate on the "group" field.
func GroupEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGroup), v))
	})
}

// GroupNEQ applies the NEQ predicate on the "group" field.
func GroupNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGroup), v))
	})
}

// GroupIn applies the In predicate on the "group" field.
func GroupIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGroup), v...))
	})
}

// GroupNotIn applies the NotIn predicate on the "group" field.
func GroupNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGroup), v...))
	})
}

// GroupGT applies the GT predicate on the "group" field.
func GroupGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGroup), v))
	})
}

// GroupGTE applies the GTE predicate on the "group" field.
func GroupGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGroup), v))
	})
}

// GroupLT applies the LT predicate on the "group" field.
func GroupLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGroup), v))
	})
}

// GroupLTE applies the LTE predicate on the "group" field.
func GroupLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGroup), v))
	})
}

// GroupContains applies the Contains predicate on the "group" field.
func GroupContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGroup), v))
	})
}

// GroupHasPrefix applies the HasPrefix predicate on the "group" field.
func GroupHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGroup), v))
	})
}

// GroupHasSuffix applies the HasSuffix predicate on the "group" field.
func GroupHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGroup), v))
	})
}

// GroupEqualFold applies the EqualFold predicate on the "group" field.
func GroupEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGroup), v))
	})
}

// GroupContainsFold applies the ContainsFold predicate on the "group" field.
func GroupContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGroup), v))
	})
}

// IndexEQ applies the EQ predicate on the "index" field.
func IndexEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIndex), v))
	})
}

// IndexNEQ applies the NEQ predicate on the "index" field.
func IndexNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIndex), v))
	})
}

// IndexIn applies the In predicate on the "index" field.
func IndexIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIndex), v...))
	})
}

// IndexNotIn applies the NotIn predicate on the "index" field.
func IndexNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIndex), v...))
	})
}

// IndexGT applies the GT predicate on the "index" field.
func IndexGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIndex), v))
	})
}

// IndexGTE applies the GTE predicate on the "index" field.
func IndexGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIndex), v))
	})
}

// IndexLT applies the LT predicate on the "index" field.
func IndexLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIndex), v))
	})
}

// IndexLTE applies the LTE predicate on the "index" field.
func IndexLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIndex), v))
	})
}

// IndexContains applies the Contains predicate on the "index" field.
func IndexContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldIndex), v))
	})
}

// IndexHasPrefix applies the HasPrefix predicate on the "index" field.
func IndexHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldIndex), v))
	})
}

// IndexHasSuffix applies the HasSuffix predicate on the "index" field.
func IndexHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldIndex), v))
	})
}

// IndexEqualFold applies the EqualFold predicate on the "index" field.
func IndexEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldIndex), v))
	})
}

// IndexContainsFold applies the ContainsFold predicate on the "index" field.
func IndexContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldIndex), v))
	})
}

// ReleaseDateEQ applies the EQ predicate on the "release_date" field.
func ReleaseDateEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateNEQ applies the NEQ predicate on the "release_date" field.
func ReleaseDateNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateIn applies the In predicate on the "release_date" field.
func ReleaseDateIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReleaseDate), v...))
	})
}

// ReleaseDateNotIn applies the NotIn predicate on the "release_date" field.
func ReleaseDateNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReleaseDate), v...))
	})
}

// ReleaseDateGT applies the GT predicate on the "release_date" field.
func ReleaseDateGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateGTE applies the GTE predicate on the "release_date" field.
func ReleaseDateGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateLT applies the LT predicate on the "release_date" field.
func ReleaseDateLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateLTE applies the LTE predicate on the "release_date" field.
func ReleaseDateLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateContains applies the Contains predicate on the "release_date" field.
func ReleaseDateContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateHasPrefix applies the HasPrefix predicate on the "release_date" field.
func ReleaseDateHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateHasSuffix applies the HasSuffix predicate on the "release_date" field.
func ReleaseDateHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateEqualFold applies the EqualFold predicate on the "release_date" field.
func ReleaseDateEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldReleaseDate), v))
	})
}

// ReleaseDateContainsFold applies the ContainsFold predicate on the "release_date" field.
func ReleaseDateContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldReleaseDate), v))
	})
}

// FormatEQ applies the EQ predicate on the "format" field.
func FormatEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFormat), v))
	})
}

// FormatNEQ applies the NEQ predicate on the "format" field.
func FormatNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFormat), v))
	})
}

// FormatIn applies the In predicate on the "format" field.
func FormatIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFormat), v...))
	})
}

// FormatNotIn applies the NotIn predicate on the "format" field.
func FormatNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFormat), v...))
	})
}

// FormatGT applies the GT predicate on the "format" field.
func FormatGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFormat), v))
	})
}

// FormatGTE applies the GTE predicate on the "format" field.
func FormatGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFormat), v))
	})
}

// FormatLT applies the LT predicate on the "format" field.
func FormatLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFormat), v))
	})
}

// FormatLTE applies the LTE predicate on the "format" field.
func FormatLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFormat), v))
	})
}

// FormatContains applies the Contains predicate on the "format" field.
func FormatContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFormat), v))
	})
}

// FormatHasPrefix applies the HasPrefix predicate on the "format" field.
func FormatHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFormat), v))
	})
}

// FormatHasSuffix applies the HasSuffix predicate on the "format" field.
func FormatHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFormat), v))
	})
}

// FormatEqualFold applies the EqualFold predicate on the "format" field.
func FormatEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFormat), v))
	})
}

// FormatContainsFold applies the ContainsFold predicate on the "format" field.
func FormatContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFormat), v))
	})
}

// SeriesEQ applies the EQ predicate on the "series" field.
func SeriesEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSeries), v))
	})
}

// SeriesNEQ applies the NEQ predicate on the "series" field.
func SeriesNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSeries), v))
	})
}

// SeriesIn applies the In predicate on the "series" field.
func SeriesIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSeries), v...))
	})
}

// SeriesNotIn applies the NotIn predicate on the "series" field.
func SeriesNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSeries), v...))
	})
}

// SeriesGT applies the GT predicate on the "series" field.
func SeriesGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSeries), v))
	})
}

// SeriesGTE applies the GTE predicate on the "series" field.
func SeriesGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSeries), v))
	})
}

// SeriesLT applies the LT predicate on the "series" field.
func SeriesLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSeries), v))
	})
}

// SeriesLTE applies the LTE predicate on the "series" field.
func SeriesLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSeries), v))
	})
}

// SeriesContains applies the Contains predicate on the "series" field.
func SeriesContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSeries), v))
	})
}

// SeriesHasPrefix applies the HasPrefix predicate on the "series" field.
func SeriesHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSeries), v))
	})
}

// SeriesHasSuffix applies the HasSuffix predicate on the "series" field.
func SeriesHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSeries), v))
	})
}

// SeriesEqualFold applies the EqualFold predicate on the "series" field.
func SeriesEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSeries), v))
	})
}

// SeriesContainsFold applies the ContainsFold predicate on the "series" field.
func SeriesContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSeries), v))
	})
}

// LengthEQ applies the EQ predicate on the "length" field.
func LengthEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLength), v))
	})
}

// LengthNEQ applies the NEQ predicate on the "length" field.
func LengthNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLength), v))
	})
}

// LengthIn applies the In predicate on the "length" field.
func LengthIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLength), v...))
	})
}

// LengthNotIn applies the NotIn predicate on the "length" field.
func LengthNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLength), v...))
	})
}

// LengthGT applies the GT predicate on the "length" field.
func LengthGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLength), v))
	})
}

// LengthGTE applies the GTE predicate on the "length" field.
func LengthGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLength), v))
	})
}

// LengthLT applies the LT predicate on the "length" field.
func LengthLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLength), v))
	})
}

// LengthLTE applies the LTE predicate on the "length" field.
func LengthLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLength), v))
	})
}

// LengthContains applies the Contains predicate on the "length" field.
func LengthContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLength), v))
	})
}

// LengthHasPrefix applies the HasPrefix predicate on the "length" field.
func LengthHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLength), v))
	})
}

// LengthHasSuffix applies the HasSuffix predicate on the "length" field.
func LengthHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLength), v))
	})
}

// LengthEqualFold applies the EqualFold predicate on the "length" field.
func LengthEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLength), v))
	})
}

// LengthContainsFold applies the ContainsFold predicate on the "length" field.
func LengthContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLength), v))
	})
}

// UncensoredEQ applies the EQ predicate on the "uncensored" field.
func UncensoredEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUncensored), v))
	})
}

// UncensoredNEQ applies the NEQ predicate on the "uncensored" field.
func UncensoredNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUncensored), v))
	})
}

// UncensoredIn applies the In predicate on the "uncensored" field.
func UncensoredIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUncensored), v...))
	})
}

// UncensoredNotIn applies the NotIn predicate on the "uncensored" field.
func UncensoredNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUncensored), v...))
	})
}

// UncensoredGT applies the GT predicate on the "uncensored" field.
func UncensoredGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUncensored), v))
	})
}

// UncensoredGTE applies the GTE predicate on the "uncensored" field.
func UncensoredGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUncensored), v))
	})
}

// UncensoredLT applies the LT predicate on the "uncensored" field.
func UncensoredLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUncensored), v))
	})
}

// UncensoredLTE applies the LTE predicate on the "uncensored" field.
func UncensoredLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUncensored), v))
	})
}

// UncensoredContains applies the Contains predicate on the "uncensored" field.
func UncensoredContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUncensored), v))
	})
}

// UncensoredHasPrefix applies the HasPrefix predicate on the "uncensored" field.
func UncensoredHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUncensored), v))
	})
}

// UncensoredHasSuffix applies the HasSuffix predicate on the "uncensored" field.
func UncensoredHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUncensored), v))
	})
}

// UncensoredEqualFold applies the EqualFold predicate on the "uncensored" field.
func UncensoredEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUncensored), v))
	})
}

// UncensoredContainsFold applies the ContainsFold predicate on the "uncensored" field.
func UncensoredContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUncensored), v))
	})
}

// SeasonEQ applies the EQ predicate on the "season" field.
func SeasonEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSeason), v))
	})
}

// SeasonNEQ applies the NEQ predicate on the "season" field.
func SeasonNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSeason), v))
	})
}

// SeasonIn applies the In predicate on the "season" field.
func SeasonIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSeason), v...))
	})
}

// SeasonNotIn applies the NotIn predicate on the "season" field.
func SeasonNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSeason), v...))
	})
}

// SeasonGT applies the GT predicate on the "season" field.
func SeasonGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSeason), v))
	})
}

// SeasonGTE applies the GTE predicate on the "season" field.
func SeasonGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSeason), v))
	})
}

// SeasonLT applies the LT predicate on the "season" field.
func SeasonLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSeason), v))
	})
}

// SeasonLTE applies the LTE predicate on the "season" field.
func SeasonLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSeason), v))
	})
}

// SeasonContains applies the Contains predicate on the "season" field.
func SeasonContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSeason), v))
	})
}

// SeasonHasPrefix applies the HasPrefix predicate on the "season" field.
func SeasonHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSeason), v))
	})
}

// SeasonHasSuffix applies the HasSuffix predicate on the "season" field.
func SeasonHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSeason), v))
	})
}

// SeasonEqualFold applies the EqualFold predicate on the "season" field.
func SeasonEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSeason), v))
	})
}

// SeasonContainsFold applies the ContainsFold predicate on the "season" field.
func SeasonContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSeason), v))
	})
}

// TotalEpisodeEQ applies the EQ predicate on the "total_episode" field.
func TotalEpisodeEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeNEQ applies the NEQ predicate on the "total_episode" field.
func TotalEpisodeNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeIn applies the In predicate on the "total_episode" field.
func TotalEpisodeIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotalEpisode), v...))
	})
}

// TotalEpisodeNotIn applies the NotIn predicate on the "total_episode" field.
func TotalEpisodeNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotalEpisode), v...))
	})
}

// TotalEpisodeGT applies the GT predicate on the "total_episode" field.
func TotalEpisodeGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeGTE applies the GTE predicate on the "total_episode" field.
func TotalEpisodeGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeLT applies the LT predicate on the "total_episode" field.
func TotalEpisodeLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeLTE applies the LTE predicate on the "total_episode" field.
func TotalEpisodeLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeContains applies the Contains predicate on the "total_episode" field.
func TotalEpisodeContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeHasPrefix applies the HasPrefix predicate on the "total_episode" field.
func TotalEpisodeHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeHasSuffix applies the HasSuffix predicate on the "total_episode" field.
func TotalEpisodeHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeEqualFold applies the EqualFold predicate on the "total_episode" field.
func TotalEpisodeEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTotalEpisode), v))
	})
}

// TotalEpisodeContainsFold applies the ContainsFold predicate on the "total_episode" field.
func TotalEpisodeContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTotalEpisode), v))
	})
}

// EpisodeEQ applies the EQ predicate on the "episode" field.
func EpisodeEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEpisode), v))
	})
}

// EpisodeNEQ applies the NEQ predicate on the "episode" field.
func EpisodeNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEpisode), v))
	})
}

// EpisodeIn applies the In predicate on the "episode" field.
func EpisodeIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEpisode), v...))
	})
}

// EpisodeNotIn applies the NotIn predicate on the "episode" field.
func EpisodeNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEpisode), v...))
	})
}

// EpisodeGT applies the GT predicate on the "episode" field.
func EpisodeGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEpisode), v))
	})
}

// EpisodeGTE applies the GTE predicate on the "episode" field.
func EpisodeGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEpisode), v))
	})
}

// EpisodeLT applies the LT predicate on the "episode" field.
func EpisodeLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEpisode), v))
	})
}

// EpisodeLTE applies the LTE predicate on the "episode" field.
func EpisodeLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEpisode), v))
	})
}

// EpisodeContains applies the Contains predicate on the "episode" field.
func EpisodeContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEpisode), v))
	})
}

// EpisodeHasPrefix applies the HasPrefix predicate on the "episode" field.
func EpisodeHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEpisode), v))
	})
}

// EpisodeHasSuffix applies the HasSuffix predicate on the "episode" field.
func EpisodeHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEpisode), v))
	})
}

// EpisodeEqualFold applies the EqualFold predicate on the "episode" field.
func EpisodeEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEpisode), v))
	})
}

// EpisodeContainsFold applies the ContainsFold predicate on the "episode" field.
func EpisodeContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEpisode), v))
	})
}

// LanguageEQ applies the EQ predicate on the "language" field.
func LanguageEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLanguage), v))
	})
}

// LanguageNEQ applies the NEQ predicate on the "language" field.
func LanguageNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLanguage), v))
	})
}

// LanguageIn applies the In predicate on the "language" field.
func LanguageIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLanguage), v...))
	})
}

// LanguageNotIn applies the NotIn predicate on the "language" field.
func LanguageNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLanguage), v...))
	})
}

// LanguageGT applies the GT predicate on the "language" field.
func LanguageGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLanguage), v))
	})
}

// LanguageGTE applies the GTE predicate on the "language" field.
func LanguageGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLanguage), v))
	})
}

// LanguageLT applies the LT predicate on the "language" field.
func LanguageLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLanguage), v))
	})
}

// LanguageLTE applies the LTE predicate on the "language" field.
func LanguageLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLanguage), v))
	})
}

// LanguageContains applies the Contains predicate on the "language" field.
func LanguageContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLanguage), v))
	})
}

// LanguageHasPrefix applies the HasPrefix predicate on the "language" field.
func LanguageHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLanguage), v))
	})
}

// LanguageHasSuffix applies the HasSuffix predicate on the "language" field.
func LanguageHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLanguage), v))
	})
}

// LanguageEqualFold applies the EqualFold predicate on the "language" field.
func LanguageEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLanguage), v))
	})
}

// LanguageContainsFold applies the ContainsFold predicate on the "language" field.
func LanguageContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLanguage), v))
	})
}

// SharpnessEQ applies the EQ predicate on the "sharpness" field.
func SharpnessEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSharpness), v))
	})
}

// SharpnessNEQ applies the NEQ predicate on the "sharpness" field.
func SharpnessNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSharpness), v))
	})
}

// SharpnessIn applies the In predicate on the "sharpness" field.
func SharpnessIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSharpness), v...))
	})
}

// SharpnessNotIn applies the NotIn predicate on the "sharpness" field.
func SharpnessNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSharpness), v...))
	})
}

// SharpnessGT applies the GT predicate on the "sharpness" field.
func SharpnessGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSharpness), v))
	})
}

// SharpnessGTE applies the GTE predicate on the "sharpness" field.
func SharpnessGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSharpness), v))
	})
}

// SharpnessLT applies the LT predicate on the "sharpness" field.
func SharpnessLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSharpness), v))
	})
}

// SharpnessLTE applies the LTE predicate on the "sharpness" field.
func SharpnessLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSharpness), v))
	})
}

// SharpnessContains applies the Contains predicate on the "sharpness" field.
func SharpnessContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSharpness), v))
	})
}

// SharpnessHasPrefix applies the HasPrefix predicate on the "sharpness" field.
func SharpnessHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSharpness), v))
	})
}

// SharpnessHasSuffix applies the HasSuffix predicate on the "sharpness" field.
func SharpnessHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSharpness), v))
	})
}

// SharpnessEqualFold applies the EqualFold predicate on the "sharpness" field.
func SharpnessEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSharpness), v))
	})
}

// SharpnessContainsFold applies the ContainsFold predicate on the "sharpness" field.
func SharpnessContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSharpness), v))
	})
}

// WatermarkEQ applies the EQ predicate on the "watermark" field.
func WatermarkEQ(v bool) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWatermark), v))
	})
}

// WatermarkNEQ applies the NEQ predicate on the "watermark" field.
func WatermarkNEQ(v bool) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWatermark), v))
	})
}

// PermissionEQ applies the EQ predicate on the "permission" field.
func PermissionEQ(v Permission) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPermission), v))
	})
}

// PermissionNEQ applies the NEQ predicate on the "permission" field.
func PermissionNEQ(v Permission) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPermission), v))
	})
}

// PermissionIn applies the In predicate on the "permission" field.
func PermissionIn(vs ...Permission) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPermission), v...))
	})
}

// PermissionNotIn applies the NotIn predicate on the "permission" field.
func PermissionNotIn(vs ...Permission) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPermission), v...))
	})
}

// SignEQ applies the EQ predicate on the "sign" field.
func SignEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSign), v))
	})
}

// SignNEQ applies the NEQ predicate on the "sign" field.
func SignNEQ(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSign), v))
	})
}

// SignIn applies the In predicate on the "sign" field.
func SignIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSign), v...))
	})
}

// SignNotIn applies the NotIn predicate on the "sign" field.
func SignNotIn(vs ...string) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSign), v...))
	})
}

// SignGT applies the GT predicate on the "sign" field.
func SignGT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSign), v))
	})
}

// SignGTE applies the GTE predicate on the "sign" field.
func SignGTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSign), v))
	})
}

// SignLT applies the LT predicate on the "sign" field.
func SignLT(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSign), v))
	})
}

// SignLTE applies the LTE predicate on the "sign" field.
func SignLTE(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSign), v))
	})
}

// SignContains applies the Contains predicate on the "sign" field.
func SignContains(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSign), v))
	})
}

// SignHasPrefix applies the HasPrefix predicate on the "sign" field.
func SignHasPrefix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSign), v))
	})
}

// SignHasSuffix applies the HasSuffix predicate on the "sign" field.
func SignHasSuffix(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSign), v))
	})
}

// SignIsNil applies the IsNil predicate on the "sign" field.
func SignIsNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSign)))
	})
}

// SignNotNil applies the NotNil predicate on the "sign" field.
func SignNotNil() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSign)))
	})
}

// SignEqualFold applies the EqualFold predicate on the "sign" field.
func SignEqualFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSign), v))
	})
}

// SignContainsFold applies the ContainsFold predicate on the "sign" field.
func SignContainsFold(v string) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSign), v))
	})
}

// TotalBlocksEQ applies the EQ predicate on the "total_blocks" field.
func TotalBlocksEQ(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalBlocks), v))
	})
}

// TotalBlocksNEQ applies the NEQ predicate on the "total_blocks" field.
func TotalBlocksNEQ(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotalBlocks), v))
	})
}

// TotalBlocksIn applies the In predicate on the "total_blocks" field.
func TotalBlocksIn(vs ...int) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotalBlocks), v...))
	})
}

// TotalBlocksNotIn applies the NotIn predicate on the "total_blocks" field.
func TotalBlocksNotIn(vs ...int) predicate.InformationV1 {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.InformationV1(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotalBlocks), v...))
	})
}

// TotalBlocksGT applies the GT predicate on the "total_blocks" field.
func TotalBlocksGT(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotalBlocks), v))
	})
}

// TotalBlocksGTE applies the GTE predicate on the "total_blocks" field.
func TotalBlocksGTE(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotalBlocks), v))
	})
}

// TotalBlocksLT applies the LT predicate on the "total_blocks" field.
func TotalBlocksLT(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotalBlocks), v))
	})
}

// TotalBlocksLTE applies the LTE predicate on the "total_blocks" field.
func TotalBlocksLTE(v int) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotalBlocks), v))
	})
}

// HasTopLists applies the HasEdge predicate on the "top_lists" edge.
func HasTopLists() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TopListsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TopListsTable, TopListsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTopListsWith applies the HasEdge predicate on the "top_lists" edge with a given conditions (other predicates).
func HasTopListsWith(preds ...predicate.TopList) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TopListsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TopListsTable, TopListsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasChannel applies the HasEdge predicate on the "channel" edge.
func HasChannel() predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChannelTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ChannelTable, ChannelColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasChannelWith applies the HasEdge predicate on the "channel" edge with a given conditions (other predicates).
func HasChannelWith(preds ...predicate.Channel) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChannelInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ChannelTable, ChannelColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.InformationV1) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.InformationV1) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.InformationV1) predicate.InformationV1 {
	return predicate.InformationV1(func(s *sql.Selector) {
		p(s.Not())
	})
}
