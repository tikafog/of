// Code generated by ent, DO NOT EDIT.

package media

import (
	"encoding/json"
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/tikafog/of/dbc/media/channel"
	"github.com/tikafog/of/dbc/media/informationv1"
	"github.com/tikafog/of/dbc/media/schema"
)

// InformationV1 is the model entity for the InformationV1 schema.
type InformationV1 struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedUnix holds the value of the "created_unix" field.
	CreatedUnix int64 `json:"created_unix,omitempty"`
	// UpdatedUnix holds the value of the "updated_unix" field.
	UpdatedUnix int64 `json:"updated_unix,omitempty"`
	// DeletedUnix holds the value of the "deleted_unix" field.
	DeletedUnix int64 `json:"deleted_unix,omitempty"`
	// ChannelID holds the value of the "channel_id" field.
	ChannelID uuid.UUID `json:"channel_id,omitempty"`
	// Root holds the value of the "root" field.
	Root string `json:"root,omitempty"`
	// Thumb holds the value of the "thumb" field.
	Thumb string `json:"thumb,omitempty"`
	// ThumbPath holds the value of the "thumb_path" field.
	ThumbPath string `json:"thumb_path,omitempty"`
	// Poster holds the value of the "poster" field.
	Poster string `json:"poster,omitempty"`
	// PosterPath holds the value of the "poster_path" field.
	PosterPath string `json:"poster_path,omitempty"`
	// Media holds the value of the "media" field.
	Media string `json:"media,omitempty"`
	// MediaPath holds the value of the "media_path" field.
	MediaPath string `json:"media_path,omitempty"`
	// MediaIndex holds the value of the "media_index" field.
	MediaIndex string `json:"media_index,omitempty"`
	// Frames holds the value of the "frames" field.
	Frames string `json:"frames,omitempty"`
	// FramesPath holds the value of the "frames_path" field.
	FramesPath string `json:"frames_path,omitempty"`
	// FramesParticulars holds the value of the "frames_particulars" field.
	FramesParticulars []schema.SkipFrame `json:"frames_particulars,omitempty"`
	// Title holds the value of the "title" field.
	Title string `json:"title,omitempty"`
	// VideoNo holds the value of the "video_no" field.
	VideoNo string `json:"video_no,omitempty"`
	// Intro holds the value of the "intro" field.
	Intro string `json:"intro,omitempty"`
	// Alias holds the value of the "alias" field.
	Alias []string `json:"alias,omitempty"`
	// Role holds the value of the "role" field.
	Role []string `json:"role,omitempty"`
	// Director holds the value of the "director" field.
	Director string `json:"director,omitempty"`
	// Systematics holds the value of the "systematics" field.
	Systematics string `json:"systematics,omitempty"`
	// Producer holds the value of the "producer" field.
	Producer string `json:"producer,omitempty"`
	// Publisher holds the value of the "publisher" field.
	Publisher string `json:"publisher,omitempty"`
	// SortType holds the value of the "sort_type" field.
	SortType string `json:"sort_type,omitempty"`
	// Caption holds the value of the "caption" field.
	Caption string `json:"caption,omitempty"`
	// Group holds the value of the "group" field.
	Group string `json:"group,omitempty"`
	// Index holds the value of the "index" field.
	Index string `json:"index,omitempty"`
	// ReleaseDate holds the value of the "release_date" field.
	ReleaseDate string `json:"release_date,omitempty"`
	// Format holds the value of the "format" field.
	Format string `json:"format,omitempty"`
	// Series holds the value of the "series" field.
	Series string `json:"series,omitempty"`
	// Tags holds the value of the "tags" field.
	Tags []string `json:"tags,omitempty"`
	// Length holds the value of the "length" field.
	Length string `json:"length,omitempty"`
	// Sample holds the value of the "sample" field.
	Sample []string `json:"sample,omitempty"`
	// Uncensored holds the value of the "uncensored" field.
	Uncensored string `json:"uncensored,omitempty"`
	// Season holds the value of the "season" field.
	Season string `json:"season,omitempty"`
	// TotalEpisode holds the value of the "total_episode" field.
	TotalEpisode string `json:"total_episode,omitempty"`
	// Episode holds the value of the "episode" field.
	Episode string `json:"episode,omitempty"`
	// Language holds the value of the "language" field.
	Language string `json:"language,omitempty"`
	// Sharpness holds the value of the "sharpness" field.
	Sharpness string `json:"sharpness,omitempty"`
	// Watermark holds the value of the "watermark" field.
	Watermark bool `json:"watermark,omitempty"`
	// Permission holds the value of the "permission" field.
	Permission informationv1.Permission `json:"permission,omitempty"`
	// Sign holds the value of the "sign" field.
	Sign string `json:"sign,omitempty"`
	// TotalBlocks holds the value of the "total_blocks" field.
	TotalBlocks int `json:"total_blocks,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the InformationV1Query when eager-loading is set.
	Edges InformationV1Edges `json:"edges"`
}

// InformationV1Edges holds the relations/edges for other nodes in the graph.
type InformationV1Edges struct {
	// TopLists holds the value of the top_lists edge.
	TopLists []*TopList `json:"top_lists,omitempty"`
	// Channel holds the value of the channel edge.
	Channel *Channel `json:"channel,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// TopListsOrErr returns the TopLists value or an error if the edge
// was not loaded in eager-loading.
func (e InformationV1Edges) TopListsOrErr() ([]*TopList, error) {
	if e.loadedTypes[0] {
		return e.TopLists, nil
	}
	return nil, &NotLoadedError{edge: "top_lists"}
}

// ChannelOrErr returns the Channel value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e InformationV1Edges) ChannelOrErr() (*Channel, error) {
	if e.loadedTypes[1] {
		if e.Channel == nil {
			// The edge channel was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: channel.Label}
		}
		return e.Channel, nil
	}
	return nil, &NotLoadedError{edge: "channel"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*InformationV1) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case informationv1.FieldFramesParticulars, informationv1.FieldAlias, informationv1.FieldRole, informationv1.FieldTags, informationv1.FieldSample:
			values[i] = new([]byte)
		case informationv1.FieldWatermark:
			values[i] = new(sql.NullBool)
		case informationv1.FieldCreatedUnix, informationv1.FieldUpdatedUnix, informationv1.FieldDeletedUnix, informationv1.FieldTotalBlocks:
			values[i] = new(sql.NullInt64)
		case informationv1.FieldRoot, informationv1.FieldThumb, informationv1.FieldThumbPath, informationv1.FieldPoster, informationv1.FieldPosterPath, informationv1.FieldMedia, informationv1.FieldMediaPath, informationv1.FieldMediaIndex, informationv1.FieldFrames, informationv1.FieldFramesPath, informationv1.FieldTitle, informationv1.FieldVideoNo, informationv1.FieldIntro, informationv1.FieldDirector, informationv1.FieldSystematics, informationv1.FieldProducer, informationv1.FieldPublisher, informationv1.FieldSortType, informationv1.FieldCaption, informationv1.FieldGroup, informationv1.FieldIndex, informationv1.FieldReleaseDate, informationv1.FieldFormat, informationv1.FieldSeries, informationv1.FieldLength, informationv1.FieldUncensored, informationv1.FieldSeason, informationv1.FieldTotalEpisode, informationv1.FieldEpisode, informationv1.FieldLanguage, informationv1.FieldSharpness, informationv1.FieldPermission, informationv1.FieldSign:
			values[i] = new(sql.NullString)
		case informationv1.FieldID, informationv1.FieldChannelID:
			values[i] = new(uuid.UUID)
		default:
			return nil, fmt.Errorf("unexpected column %q for type InformationV1", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the InformationV1 fields.
func (i *InformationV1) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for j := range columns {
		switch columns[j] {
		case informationv1.FieldID:
			if value, ok := values[j].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[j])
			} else if value != nil {
				i.ID = *value
			}
		case informationv1.FieldCreatedUnix:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field created_unix", values[j])
			} else if value.Valid {
				i.CreatedUnix = value.Int64
			}
		case informationv1.FieldUpdatedUnix:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updated_unix", values[j])
			} else if value.Valid {
				i.UpdatedUnix = value.Int64
			}
		case informationv1.FieldDeletedUnix:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_unix", values[j])
			} else if value.Valid {
				i.DeletedUnix = value.Int64
			}
		case informationv1.FieldChannelID:
			if value, ok := values[j].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field channel_id", values[j])
			} else if value != nil {
				i.ChannelID = *value
			}
		case informationv1.FieldRoot:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field root", values[j])
			} else if value.Valid {
				i.Root = value.String
			}
		case informationv1.FieldThumb:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field thumb", values[j])
			} else if value.Valid {
				i.Thumb = value.String
			}
		case informationv1.FieldThumbPath:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field thumb_path", values[j])
			} else if value.Valid {
				i.ThumbPath = value.String
			}
		case informationv1.FieldPoster:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field poster", values[j])
			} else if value.Valid {
				i.Poster = value.String
			}
		case informationv1.FieldPosterPath:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field poster_path", values[j])
			} else if value.Valid {
				i.PosterPath = value.String
			}
		case informationv1.FieldMedia:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field media", values[j])
			} else if value.Valid {
				i.Media = value.String
			}
		case informationv1.FieldMediaPath:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field media_path", values[j])
			} else if value.Valid {
				i.MediaPath = value.String
			}
		case informationv1.FieldMediaIndex:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field media_index", values[j])
			} else if value.Valid {
				i.MediaIndex = value.String
			}
		case informationv1.FieldFrames:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field frames", values[j])
			} else if value.Valid {
				i.Frames = value.String
			}
		case informationv1.FieldFramesPath:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field frames_path", values[j])
			} else if value.Valid {
				i.FramesPath = value.String
			}
		case informationv1.FieldFramesParticulars:
			if value, ok := values[j].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field frames_particulars", values[j])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &i.FramesParticulars); err != nil {
					return fmt.Errorf("unmarshal field frames_particulars: %w", err)
				}
			}
		case informationv1.FieldTitle:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field title", values[j])
			} else if value.Valid {
				i.Title = value.String
			}
		case informationv1.FieldVideoNo:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field video_no", values[j])
			} else if value.Valid {
				i.VideoNo = value.String
			}
		case informationv1.FieldIntro:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field intro", values[j])
			} else if value.Valid {
				i.Intro = value.String
			}
		case informationv1.FieldAlias:
			if value, ok := values[j].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field alias", values[j])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &i.Alias); err != nil {
					return fmt.Errorf("unmarshal field alias: %w", err)
				}
			}
		case informationv1.FieldRole:
			if value, ok := values[j].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field role", values[j])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &i.Role); err != nil {
					return fmt.Errorf("unmarshal field role: %w", err)
				}
			}
		case informationv1.FieldDirector:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field director", values[j])
			} else if value.Valid {
				i.Director = value.String
			}
		case informationv1.FieldSystematics:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field systematics", values[j])
			} else if value.Valid {
				i.Systematics = value.String
			}
		case informationv1.FieldProducer:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field producer", values[j])
			} else if value.Valid {
				i.Producer = value.String
			}
		case informationv1.FieldPublisher:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field publisher", values[j])
			} else if value.Valid {
				i.Publisher = value.String
			}
		case informationv1.FieldSortType:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sort_type", values[j])
			} else if value.Valid {
				i.SortType = value.String
			}
		case informationv1.FieldCaption:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field caption", values[j])
			} else if value.Valid {
				i.Caption = value.String
			}
		case informationv1.FieldGroup:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field group", values[j])
			} else if value.Valid {
				i.Group = value.String
			}
		case informationv1.FieldIndex:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field index", values[j])
			} else if value.Valid {
				i.Index = value.String
			}
		case informationv1.FieldReleaseDate:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field release_date", values[j])
			} else if value.Valid {
				i.ReleaseDate = value.String
			}
		case informationv1.FieldFormat:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field format", values[j])
			} else if value.Valid {
				i.Format = value.String
			}
		case informationv1.FieldSeries:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field series", values[j])
			} else if value.Valid {
				i.Series = value.String
			}
		case informationv1.FieldTags:
			if value, ok := values[j].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[j])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &i.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case informationv1.FieldLength:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field length", values[j])
			} else if value.Valid {
				i.Length = value.String
			}
		case informationv1.FieldSample:
			if value, ok := values[j].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field sample", values[j])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &i.Sample); err != nil {
					return fmt.Errorf("unmarshal field sample: %w", err)
				}
			}
		case informationv1.FieldUncensored:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field uncensored", values[j])
			} else if value.Valid {
				i.Uncensored = value.String
			}
		case informationv1.FieldSeason:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field season", values[j])
			} else if value.Valid {
				i.Season = value.String
			}
		case informationv1.FieldTotalEpisode:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field total_episode", values[j])
			} else if value.Valid {
				i.TotalEpisode = value.String
			}
		case informationv1.FieldEpisode:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field episode", values[j])
			} else if value.Valid {
				i.Episode = value.String
			}
		case informationv1.FieldLanguage:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language", values[j])
			} else if value.Valid {
				i.Language = value.String
			}
		case informationv1.FieldSharpness:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sharpness", values[j])
			} else if value.Valid {
				i.Sharpness = value.String
			}
		case informationv1.FieldWatermark:
			if value, ok := values[j].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field watermark", values[j])
			} else if value.Valid {
				i.Watermark = value.Bool
			}
		case informationv1.FieldPermission:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field permission", values[j])
			} else if value.Valid {
				i.Permission = informationv1.Permission(value.String)
			}
		case informationv1.FieldSign:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sign", values[j])
			} else if value.Valid {
				i.Sign = value.String
			}
		case informationv1.FieldTotalBlocks:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_blocks", values[j])
			} else if value.Valid {
				i.TotalBlocks = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryTopLists queries the "top_lists" edge of the InformationV1 entity.
func (i *InformationV1) QueryTopLists() *TopListQuery {
	return (&InformationV1Client{config: i.config}).QueryTopLists(i)
}

// QueryChannel queries the "channel" edge of the InformationV1 entity.
func (i *InformationV1) QueryChannel() *ChannelQuery {
	return (&InformationV1Client{config: i.config}).QueryChannel(i)
}

// Update returns a builder for updating this InformationV1.
// Note that you need to call InformationV1.Unwrap() before calling this method if this InformationV1
// was returned from a transaction, and the transaction was committed or rolled back.
func (i *InformationV1) Update() *InformationV1UpdateOne {
	return (&InformationV1Client{config: i.config}).UpdateOne(i)
}

// Unwrap unwraps the InformationV1 entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (i *InformationV1) Unwrap() *InformationV1 {
	_tx, ok := i.config.driver.(*txDriver)
	if !ok {
		panic("media: InformationV1 is not a transactional entity")
	}
	i.config.driver = _tx.drv
	return i
}

// String implements the fmt.Stringer.
func (i *InformationV1) String() string {
	var builder strings.Builder
	builder.WriteString("InformationV1(")
	builder.WriteString(fmt.Sprintf("id=%v, ", i.ID))
	builder.WriteString("created_unix=")
	builder.WriteString(fmt.Sprintf("%v", i.CreatedUnix))
	builder.WriteString(", ")
	builder.WriteString("updated_unix=")
	builder.WriteString(fmt.Sprintf("%v", i.UpdatedUnix))
	builder.WriteString(", ")
	builder.WriteString("deleted_unix=")
	builder.WriteString(fmt.Sprintf("%v", i.DeletedUnix))
	builder.WriteString(", ")
	builder.WriteString("channel_id=")
	builder.WriteString(fmt.Sprintf("%v", i.ChannelID))
	builder.WriteString(", ")
	builder.WriteString("root=")
	builder.WriteString(i.Root)
	builder.WriteString(", ")
	builder.WriteString("thumb=")
	builder.WriteString(i.Thumb)
	builder.WriteString(", ")
	builder.WriteString("thumb_path=")
	builder.WriteString(i.ThumbPath)
	builder.WriteString(", ")
	builder.WriteString("poster=")
	builder.WriteString(i.Poster)
	builder.WriteString(", ")
	builder.WriteString("poster_path=")
	builder.WriteString(i.PosterPath)
	builder.WriteString(", ")
	builder.WriteString("media=")
	builder.WriteString(i.Media)
	builder.WriteString(", ")
	builder.WriteString("media_path=")
	builder.WriteString(i.MediaPath)
	builder.WriteString(", ")
	builder.WriteString("media_index=")
	builder.WriteString(i.MediaIndex)
	builder.WriteString(", ")
	builder.WriteString("frames=")
	builder.WriteString(i.Frames)
	builder.WriteString(", ")
	builder.WriteString("frames_path=")
	builder.WriteString(i.FramesPath)
	builder.WriteString(", ")
	builder.WriteString("frames_particulars=")
	builder.WriteString(fmt.Sprintf("%v", i.FramesParticulars))
	builder.WriteString(", ")
	builder.WriteString("title=")
	builder.WriteString(i.Title)
	builder.WriteString(", ")
	builder.WriteString("video_no=")
	builder.WriteString(i.VideoNo)
	builder.WriteString(", ")
	builder.WriteString("intro=")
	builder.WriteString(i.Intro)
	builder.WriteString(", ")
	builder.WriteString("alias=")
	builder.WriteString(fmt.Sprintf("%v", i.Alias))
	builder.WriteString(", ")
	builder.WriteString("role=")
	builder.WriteString(fmt.Sprintf("%v", i.Role))
	builder.WriteString(", ")
	builder.WriteString("director=")
	builder.WriteString(i.Director)
	builder.WriteString(", ")
	builder.WriteString("systematics=")
	builder.WriteString(i.Systematics)
	builder.WriteString(", ")
	builder.WriteString("producer=")
	builder.WriteString(i.Producer)
	builder.WriteString(", ")
	builder.WriteString("publisher=")
	builder.WriteString(i.Publisher)
	builder.WriteString(", ")
	builder.WriteString("sort_type=")
	builder.WriteString(i.SortType)
	builder.WriteString(", ")
	builder.WriteString("caption=")
	builder.WriteString(i.Caption)
	builder.WriteString(", ")
	builder.WriteString("group=")
	builder.WriteString(i.Group)
	builder.WriteString(", ")
	builder.WriteString("index=")
	builder.WriteString(i.Index)
	builder.WriteString(", ")
	builder.WriteString("release_date=")
	builder.WriteString(i.ReleaseDate)
	builder.WriteString(", ")
	builder.WriteString("format=")
	builder.WriteString(i.Format)
	builder.WriteString(", ")
	builder.WriteString("series=")
	builder.WriteString(i.Series)
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", i.Tags))
	builder.WriteString(", ")
	builder.WriteString("length=")
	builder.WriteString(i.Length)
	builder.WriteString(", ")
	builder.WriteString("sample=")
	builder.WriteString(fmt.Sprintf("%v", i.Sample))
	builder.WriteString(", ")
	builder.WriteString("uncensored=")
	builder.WriteString(i.Uncensored)
	builder.WriteString(", ")
	builder.WriteString("season=")
	builder.WriteString(i.Season)
	builder.WriteString(", ")
	builder.WriteString("total_episode=")
	builder.WriteString(i.TotalEpisode)
	builder.WriteString(", ")
	builder.WriteString("episode=")
	builder.WriteString(i.Episode)
	builder.WriteString(", ")
	builder.WriteString("language=")
	builder.WriteString(i.Language)
	builder.WriteString(", ")
	builder.WriteString("sharpness=")
	builder.WriteString(i.Sharpness)
	builder.WriteString(", ")
	builder.WriteString("watermark=")
	builder.WriteString(fmt.Sprintf("%v", i.Watermark))
	builder.WriteString(", ")
	builder.WriteString("permission=")
	builder.WriteString(fmt.Sprintf("%v", i.Permission))
	builder.WriteString(", ")
	builder.WriteString("sign=")
	builder.WriteString(i.Sign)
	builder.WriteString(", ")
	builder.WriteString("total_blocks=")
	builder.WriteString(fmt.Sprintf("%v", i.TotalBlocks))
	builder.WriteByte(')')
	return builder.String()
}

// InformationV1s is a parsable slice of InformationV1.
type InformationV1s []*InformationV1

func (i InformationV1s) config(cfg config) {
	for _i := range i {
		i[_i].config = cfg
	}
}
