// Code generated by entc, DO NOT EDIT.

package media

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/google/uuid"
	"github.com/tikafog/of/dbc/media/announce"
	"github.com/tikafog/of/dbc/media/channel"
	"github.com/tikafog/of/dbc/media/discovery"
	"github.com/tikafog/of/dbc/media/informationv1"
	"github.com/tikafog/of/dbc/media/page"
	"github.com/tikafog/of/dbc/media/predicate"
	"github.com/tikafog/of/dbc/media/schema"
	"github.com/tikafog/of/dbc/media/toplist"
	"github.com/tikafog/of/dbc/media/version"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnounce      = "Announce"
	TypeChannel       = "Channel"
	TypeDiscovery     = "Discovery"
	TypeInformationV1 = "InformationV1"
	TypePage          = "Page"
	TypeTopList       = "TopList"
	TypeVersion       = "Version"
)

// AnnounceMutation represents an operation that mutates the Announce nodes in the graph.
type AnnounceMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_unix    *int64
	addcreated_unix *int64
	updated_unix    *int64
	addupdated_unix *int64
	deleted_unix    *int64
	adddeleted_unix *int64
	announce_no     *string
	title           *string
	kind            *announce.Kind
	content         *string
	link            *string
	sign            *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Announce, error)
	predicates      []predicate.Announce
}

var _ ent.Mutation = (*AnnounceMutation)(nil)

// announceOption allows management of the mutation configuration using functional options.
type announceOption func(*AnnounceMutation)

// newAnnounceMutation creates new mutation for the Announce entity.
func newAnnounceMutation(c config, op Op, opts ...announceOption) *AnnounceMutation {
	m := &AnnounceMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnounce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnounceID sets the ID field of the mutation.
func withAnnounceID(id uuid.UUID) announceOption {
	return func(m *AnnounceMutation) {
		var (
			err   error
			once  sync.Once
			value *Announce
		)
		m.oldValue = func(ctx context.Context) (*Announce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Announce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnounce sets the old Announce of the mutation.
func withAnnounce(node *Announce) announceOption {
	return func(m *AnnounceMutation) {
		m.oldValue = func(context.Context) (*Announce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnounceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnounceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Announce entities.
func (m *AnnounceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnounceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnounceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Announce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedUnix sets the "created_unix" field.
func (m *AnnounceMutation) SetCreatedUnix(i int64) {
	m.created_unix = &i
	m.addcreated_unix = nil
}

// CreatedUnix returns the value of the "created_unix" field in the mutation.
func (m *AnnounceMutation) CreatedUnix() (r int64, exists bool) {
	v := m.created_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedUnix returns the old "created_unix" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldCreatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedUnix: %w", err)
	}
	return oldValue.CreatedUnix, nil
}

// AddCreatedUnix adds i to the "created_unix" field.
func (m *AnnounceMutation) AddCreatedUnix(i int64) {
	if m.addcreated_unix != nil {
		*m.addcreated_unix += i
	} else {
		m.addcreated_unix = &i
	}
}

// AddedCreatedUnix returns the value that was added to the "created_unix" field in this mutation.
func (m *AnnounceMutation) AddedCreatedUnix() (r int64, exists bool) {
	v := m.addcreated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedUnix resets all changes to the "created_unix" field.
func (m *AnnounceMutation) ResetCreatedUnix() {
	m.created_unix = nil
	m.addcreated_unix = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *AnnounceMutation) SetUpdatedUnix(i int64) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *AnnounceMutation) UpdatedUnix() (r int64, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldUpdatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *AnnounceMutation) AddUpdatedUnix(i int64) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *AnnounceMutation) AddedUpdatedUnix() (r int64, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *AnnounceMutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// SetDeletedUnix sets the "deleted_unix" field.
func (m *AnnounceMutation) SetDeletedUnix(i int64) {
	m.deleted_unix = &i
	m.adddeleted_unix = nil
}

// DeletedUnix returns the value of the "deleted_unix" field in the mutation.
func (m *AnnounceMutation) DeletedUnix() (r int64, exists bool) {
	v := m.deleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedUnix returns the old "deleted_unix" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldDeletedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedUnix: %w", err)
	}
	return oldValue.DeletedUnix, nil
}

// AddDeletedUnix adds i to the "deleted_unix" field.
func (m *AnnounceMutation) AddDeletedUnix(i int64) {
	if m.adddeleted_unix != nil {
		*m.adddeleted_unix += i
	} else {
		m.adddeleted_unix = &i
	}
}

// AddedDeletedUnix returns the value that was added to the "deleted_unix" field in this mutation.
func (m *AnnounceMutation) AddedDeletedUnix() (r int64, exists bool) {
	v := m.adddeleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedUnix clears the value of the "deleted_unix" field.
func (m *AnnounceMutation) ClearDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	m.clearedFields[announce.FieldDeletedUnix] = struct{}{}
}

// DeletedUnixCleared returns if the "deleted_unix" field was cleared in this mutation.
func (m *AnnounceMutation) DeletedUnixCleared() bool {
	_, ok := m.clearedFields[announce.FieldDeletedUnix]
	return ok
}

// ResetDeletedUnix resets all changes to the "deleted_unix" field.
func (m *AnnounceMutation) ResetDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	delete(m.clearedFields, announce.FieldDeletedUnix)
}

// SetAnnounceNo sets the "announce_no" field.
func (m *AnnounceMutation) SetAnnounceNo(s string) {
	m.announce_no = &s
}

// AnnounceNo returns the value of the "announce_no" field in the mutation.
func (m *AnnounceMutation) AnnounceNo() (r string, exists bool) {
	v := m.announce_no
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnounceNo returns the old "announce_no" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldAnnounceNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnounceNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnounceNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnounceNo: %w", err)
	}
	return oldValue.AnnounceNo, nil
}

// ResetAnnounceNo resets all changes to the "announce_no" field.
func (m *AnnounceMutation) ResetAnnounceNo() {
	m.announce_no = nil
}

// SetTitle sets the "title" field.
func (m *AnnounceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AnnounceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AnnounceMutation) ResetTitle() {
	m.title = nil
}

// SetKind sets the "kind" field.
func (m *AnnounceMutation) SetKind(a announce.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AnnounceMutation) Kind() (r announce.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldKind(ctx context.Context) (v announce.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AnnounceMutation) ResetKind() {
	m.kind = nil
}

// SetContent sets the "content" field.
func (m *AnnounceMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AnnounceMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AnnounceMutation) ResetContent() {
	m.content = nil
}

// SetLink sets the "link" field.
func (m *AnnounceMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *AnnounceMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *AnnounceMutation) ResetLink() {
	m.link = nil
}

// SetSign sets the "sign" field.
func (m *AnnounceMutation) SetSign(s string) {
	m.sign = &s
}

// Sign returns the value of the "sign" field in the mutation.
func (m *AnnounceMutation) Sign() (r string, exists bool) {
	v := m.sign
	if v == nil {
		return
	}
	return *v, true
}

// OldSign returns the old "sign" field's value of the Announce entity.
// If the Announce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnounceMutation) OldSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSign: %w", err)
	}
	return oldValue.Sign, nil
}

// ClearSign clears the value of the "sign" field.
func (m *AnnounceMutation) ClearSign() {
	m.sign = nil
	m.clearedFields[announce.FieldSign] = struct{}{}
}

// SignCleared returns if the "sign" field was cleared in this mutation.
func (m *AnnounceMutation) SignCleared() bool {
	_, ok := m.clearedFields[announce.FieldSign]
	return ok
}

// ResetSign resets all changes to the "sign" field.
func (m *AnnounceMutation) ResetSign() {
	m.sign = nil
	delete(m.clearedFields, announce.FieldSign)
}

// Where appends a list predicates to the AnnounceMutation builder.
func (m *AnnounceMutation) Where(ps ...predicate.Announce) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AnnounceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Announce).
func (m *AnnounceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnounceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_unix != nil {
		fields = append(fields, announce.FieldCreatedUnix)
	}
	if m.updated_unix != nil {
		fields = append(fields, announce.FieldUpdatedUnix)
	}
	if m.deleted_unix != nil {
		fields = append(fields, announce.FieldDeletedUnix)
	}
	if m.announce_no != nil {
		fields = append(fields, announce.FieldAnnounceNo)
	}
	if m.title != nil {
		fields = append(fields, announce.FieldTitle)
	}
	if m.kind != nil {
		fields = append(fields, announce.FieldKind)
	}
	if m.content != nil {
		fields = append(fields, announce.FieldContent)
	}
	if m.link != nil {
		fields = append(fields, announce.FieldLink)
	}
	if m.sign != nil {
		fields = append(fields, announce.FieldSign)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnounceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announce.FieldCreatedUnix:
		return m.CreatedUnix()
	case announce.FieldUpdatedUnix:
		return m.UpdatedUnix()
	case announce.FieldDeletedUnix:
		return m.DeletedUnix()
	case announce.FieldAnnounceNo:
		return m.AnnounceNo()
	case announce.FieldTitle:
		return m.Title()
	case announce.FieldKind:
		return m.Kind()
	case announce.FieldContent:
		return m.Content()
	case announce.FieldLink:
		return m.Link()
	case announce.FieldSign:
		return m.Sign()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnounceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announce.FieldCreatedUnix:
		return m.OldCreatedUnix(ctx)
	case announce.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	case announce.FieldDeletedUnix:
		return m.OldDeletedUnix(ctx)
	case announce.FieldAnnounceNo:
		return m.OldAnnounceNo(ctx)
	case announce.FieldTitle:
		return m.OldTitle(ctx)
	case announce.FieldKind:
		return m.OldKind(ctx)
	case announce.FieldContent:
		return m.OldContent(ctx)
	case announce.FieldLink:
		return m.OldLink(ctx)
	case announce.FieldSign:
		return m.OldSign(ctx)
	}
	return nil, fmt.Errorf("unknown Announce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnounceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announce.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedUnix(v)
		return nil
	case announce.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	case announce.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedUnix(v)
		return nil
	case announce.FieldAnnounceNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnounceNo(v)
		return nil
	case announce.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case announce.FieldKind:
		v, ok := value.(announce.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case announce.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case announce.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case announce.FieldSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSign(v)
		return nil
	}
	return fmt.Errorf("unknown Announce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnounceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_unix != nil {
		fields = append(fields, announce.FieldCreatedUnix)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, announce.FieldUpdatedUnix)
	}
	if m.adddeleted_unix != nil {
		fields = append(fields, announce.FieldDeletedUnix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnounceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case announce.FieldCreatedUnix:
		return m.AddedCreatedUnix()
	case announce.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	case announce.FieldDeletedUnix:
		return m.AddedDeletedUnix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnounceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case announce.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedUnix(v)
		return nil
	case announce.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	case announce.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedUnix(v)
		return nil
	}
	return fmt.Errorf("unknown Announce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnounceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(announce.FieldDeletedUnix) {
		fields = append(fields, announce.FieldDeletedUnix)
	}
	if m.FieldCleared(announce.FieldSign) {
		fields = append(fields, announce.FieldSign)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnounceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnounceMutation) ClearField(name string) error {
	switch name {
	case announce.FieldDeletedUnix:
		m.ClearDeletedUnix()
		return nil
	case announce.FieldSign:
		m.ClearSign()
		return nil
	}
	return fmt.Errorf("unknown Announce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnounceMutation) ResetField(name string) error {
	switch name {
	case announce.FieldCreatedUnix:
		m.ResetCreatedUnix()
		return nil
	case announce.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	case announce.FieldDeletedUnix:
		m.ResetDeletedUnix()
		return nil
	case announce.FieldAnnounceNo:
		m.ResetAnnounceNo()
		return nil
	case announce.FieldTitle:
		m.ResetTitle()
		return nil
	case announce.FieldKind:
		m.ResetKind()
		return nil
	case announce.FieldContent:
		m.ResetContent()
		return nil
	case announce.FieldLink:
		m.ResetLink()
		return nil
	case announce.FieldSign:
		m.ResetSign()
		return nil
	}
	return fmt.Errorf("unknown Announce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnounceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnounceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnounceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnounceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnounceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnounceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnounceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Announce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnounceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Announce edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_unix        *int64
	addcreated_unix     *int64
	updated_unix        *int64
	addupdated_unix     *int64
	deleted_unix        *int64
	adddeleted_unix     *int64
	comment             *string
	clearedFields       map[string]struct{}
	informations        map[uuid.UUID]struct{}
	removedinformations map[uuid.UUID]struct{}
	clearedinformations bool
	done                bool
	oldValue            func(context.Context) (*Channel, error)
	predicates          []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id uuid.UUID) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Channel entities.
func (m *ChannelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedUnix sets the "created_unix" field.
func (m *ChannelMutation) SetCreatedUnix(i int64) {
	m.created_unix = &i
	m.addcreated_unix = nil
}

// CreatedUnix returns the value of the "created_unix" field in the mutation.
func (m *ChannelMutation) CreatedUnix() (r int64, exists bool) {
	v := m.created_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedUnix returns the old "created_unix" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedUnix: %w", err)
	}
	return oldValue.CreatedUnix, nil
}

// AddCreatedUnix adds i to the "created_unix" field.
func (m *ChannelMutation) AddCreatedUnix(i int64) {
	if m.addcreated_unix != nil {
		*m.addcreated_unix += i
	} else {
		m.addcreated_unix = &i
	}
}

// AddedCreatedUnix returns the value that was added to the "created_unix" field in this mutation.
func (m *ChannelMutation) AddedCreatedUnix() (r int64, exists bool) {
	v := m.addcreated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedUnix resets all changes to the "created_unix" field.
func (m *ChannelMutation) ResetCreatedUnix() {
	m.created_unix = nil
	m.addcreated_unix = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *ChannelMutation) SetUpdatedUnix(i int64) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *ChannelMutation) UpdatedUnix() (r int64, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *ChannelMutation) AddUpdatedUnix(i int64) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *ChannelMutation) AddedUpdatedUnix() (r int64, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *ChannelMutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// SetDeletedUnix sets the "deleted_unix" field.
func (m *ChannelMutation) SetDeletedUnix(i int64) {
	m.deleted_unix = &i
	m.adddeleted_unix = nil
}

// DeletedUnix returns the value of the "deleted_unix" field in the mutation.
func (m *ChannelMutation) DeletedUnix() (r int64, exists bool) {
	v := m.deleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedUnix returns the old "deleted_unix" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedUnix: %w", err)
	}
	return oldValue.DeletedUnix, nil
}

// AddDeletedUnix adds i to the "deleted_unix" field.
func (m *ChannelMutation) AddDeletedUnix(i int64) {
	if m.adddeleted_unix != nil {
		*m.adddeleted_unix += i
	} else {
		m.adddeleted_unix = &i
	}
}

// AddedDeletedUnix returns the value that was added to the "deleted_unix" field in this mutation.
func (m *ChannelMutation) AddedDeletedUnix() (r int64, exists bool) {
	v := m.adddeleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedUnix clears the value of the "deleted_unix" field.
func (m *ChannelMutation) ClearDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	m.clearedFields[channel.FieldDeletedUnix] = struct{}{}
}

// DeletedUnixCleared returns if the "deleted_unix" field was cleared in this mutation.
func (m *ChannelMutation) DeletedUnixCleared() bool {
	_, ok := m.clearedFields[channel.FieldDeletedUnix]
	return ok
}

// ResetDeletedUnix resets all changes to the "deleted_unix" field.
func (m *ChannelMutation) ResetDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	delete(m.clearedFields, channel.FieldDeletedUnix)
}

// SetComment sets the "comment" field.
func (m *ChannelMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ChannelMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ChannelMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[channel.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ChannelMutation) CommentCleared() bool {
	_, ok := m.clearedFields[channel.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ChannelMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, channel.FieldComment)
}

// AddInformationIDs adds the "informations" edge to the InformationV1 entity by ids.
func (m *ChannelMutation) AddInformationIDs(ids ...uuid.UUID) {
	if m.informations == nil {
		m.informations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.informations[ids[i]] = struct{}{}
	}
}

// ClearInformations clears the "informations" edge to the InformationV1 entity.
func (m *ChannelMutation) ClearInformations() {
	m.clearedinformations = true
}

// InformationsCleared reports if the "informations" edge to the InformationV1 entity was cleared.
func (m *ChannelMutation) InformationsCleared() bool {
	return m.clearedinformations
}

// RemoveInformationIDs removes the "informations" edge to the InformationV1 entity by IDs.
func (m *ChannelMutation) RemoveInformationIDs(ids ...uuid.UUID) {
	if m.removedinformations == nil {
		m.removedinformations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.informations, ids[i])
		m.removedinformations[ids[i]] = struct{}{}
	}
}

// RemovedInformations returns the removed IDs of the "informations" edge to the InformationV1 entity.
func (m *ChannelMutation) RemovedInformationsIDs() (ids []uuid.UUID) {
	for id := range m.removedinformations {
		ids = append(ids, id)
	}
	return
}

// InformationsIDs returns the "informations" edge IDs in the mutation.
func (m *ChannelMutation) InformationsIDs() (ids []uuid.UUID) {
	for id := range m.informations {
		ids = append(ids, id)
	}
	return
}

// ResetInformations resets all changes to the "informations" edge.
func (m *ChannelMutation) ResetInformations() {
	m.informations = nil
	m.clearedinformations = false
	m.removedinformations = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_unix != nil {
		fields = append(fields, channel.FieldCreatedUnix)
	}
	if m.updated_unix != nil {
		fields = append(fields, channel.FieldUpdatedUnix)
	}
	if m.deleted_unix != nil {
		fields = append(fields, channel.FieldDeletedUnix)
	}
	if m.comment != nil {
		fields = append(fields, channel.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedUnix:
		return m.CreatedUnix()
	case channel.FieldUpdatedUnix:
		return m.UpdatedUnix()
	case channel.FieldDeletedUnix:
		return m.DeletedUnix()
	case channel.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedUnix:
		return m.OldCreatedUnix(ctx)
	case channel.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	case channel.FieldDeletedUnix:
		return m.OldDeletedUnix(ctx)
	case channel.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedUnix(v)
		return nil
	case channel.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	case channel.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedUnix(v)
		return nil
	case channel.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_unix != nil {
		fields = append(fields, channel.FieldCreatedUnix)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, channel.FieldUpdatedUnix)
	}
	if m.adddeleted_unix != nil {
		fields = append(fields, channel.FieldDeletedUnix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedUnix:
		return m.AddedCreatedUnix()
	case channel.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	case channel.FieldDeletedUnix:
		return m.AddedDeletedUnix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedUnix(v)
		return nil
	case channel.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	case channel.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedUnix(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldDeletedUnix) {
		fields = append(fields, channel.FieldDeletedUnix)
	}
	if m.FieldCleared(channel.FieldComment) {
		fields = append(fields, channel.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldDeletedUnix:
		m.ClearDeletedUnix()
		return nil
	case channel.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedUnix:
		m.ResetCreatedUnix()
		return nil
	case channel.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	case channel.FieldDeletedUnix:
		m.ResetDeletedUnix()
		return nil
	case channel.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.informations != nil {
		edges = append(edges, channel.EdgeInformations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeInformations:
		ids := make([]ent.Value, 0, len(m.informations))
		for id := range m.informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinformations != nil {
		edges = append(edges, channel.EdgeInformations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeInformations:
		ids := make([]ent.Value, 0, len(m.removedinformations))
		for id := range m.removedinformations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinformations {
		edges = append(edges, channel.EdgeInformations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeInformations:
		return m.clearedinformations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeInformations:
		m.ResetInformations()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// DiscoveryMutation represents an operation that mutates the Discovery nodes in the graph.
type DiscoveryMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_unix    *int64
	addcreated_unix *int64
	updated_unix    *int64
	addupdated_unix *int64
	deleted_unix    *int64
	adddeleted_unix *int64
	date            *string
	rid             *string
	title           *string
	detail          *string
	mtype           *discovery.Mtype
	links           *[]string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Discovery, error)
	predicates      []predicate.Discovery
}

var _ ent.Mutation = (*DiscoveryMutation)(nil)

// discoveryOption allows management of the mutation configuration using functional options.
type discoveryOption func(*DiscoveryMutation)

// newDiscoveryMutation creates new mutation for the Discovery entity.
func newDiscoveryMutation(c config, op Op, opts ...discoveryOption) *DiscoveryMutation {
	m := &DiscoveryMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscovery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscoveryID sets the ID field of the mutation.
func withDiscoveryID(id uuid.UUID) discoveryOption {
	return func(m *DiscoveryMutation) {
		var (
			err   error
			once  sync.Once
			value *Discovery
		)
		m.oldValue = func(ctx context.Context) (*Discovery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Discovery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscovery sets the old Discovery of the mutation.
func withDiscovery(node *Discovery) discoveryOption {
	return func(m *DiscoveryMutation) {
		m.oldValue = func(context.Context) (*Discovery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscoveryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscoveryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Discovery entities.
func (m *DiscoveryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscoveryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscoveryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Discovery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedUnix sets the "created_unix" field.
func (m *DiscoveryMutation) SetCreatedUnix(i int64) {
	m.created_unix = &i
	m.addcreated_unix = nil
}

// CreatedUnix returns the value of the "created_unix" field in the mutation.
func (m *DiscoveryMutation) CreatedUnix() (r int64, exists bool) {
	v := m.created_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedUnix returns the old "created_unix" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldCreatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedUnix: %w", err)
	}
	return oldValue.CreatedUnix, nil
}

// AddCreatedUnix adds i to the "created_unix" field.
func (m *DiscoveryMutation) AddCreatedUnix(i int64) {
	if m.addcreated_unix != nil {
		*m.addcreated_unix += i
	} else {
		m.addcreated_unix = &i
	}
}

// AddedCreatedUnix returns the value that was added to the "created_unix" field in this mutation.
func (m *DiscoveryMutation) AddedCreatedUnix() (r int64, exists bool) {
	v := m.addcreated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedUnix resets all changes to the "created_unix" field.
func (m *DiscoveryMutation) ResetCreatedUnix() {
	m.created_unix = nil
	m.addcreated_unix = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *DiscoveryMutation) SetUpdatedUnix(i int64) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *DiscoveryMutation) UpdatedUnix() (r int64, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldUpdatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *DiscoveryMutation) AddUpdatedUnix(i int64) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *DiscoveryMutation) AddedUpdatedUnix() (r int64, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *DiscoveryMutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// SetDeletedUnix sets the "deleted_unix" field.
func (m *DiscoveryMutation) SetDeletedUnix(i int64) {
	m.deleted_unix = &i
	m.adddeleted_unix = nil
}

// DeletedUnix returns the value of the "deleted_unix" field in the mutation.
func (m *DiscoveryMutation) DeletedUnix() (r int64, exists bool) {
	v := m.deleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedUnix returns the old "deleted_unix" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldDeletedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedUnix: %w", err)
	}
	return oldValue.DeletedUnix, nil
}

// AddDeletedUnix adds i to the "deleted_unix" field.
func (m *DiscoveryMutation) AddDeletedUnix(i int64) {
	if m.adddeleted_unix != nil {
		*m.adddeleted_unix += i
	} else {
		m.adddeleted_unix = &i
	}
}

// AddedDeletedUnix returns the value that was added to the "deleted_unix" field in this mutation.
func (m *DiscoveryMutation) AddedDeletedUnix() (r int64, exists bool) {
	v := m.adddeleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedUnix clears the value of the "deleted_unix" field.
func (m *DiscoveryMutation) ClearDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	m.clearedFields[discovery.FieldDeletedUnix] = struct{}{}
}

// DeletedUnixCleared returns if the "deleted_unix" field was cleared in this mutation.
func (m *DiscoveryMutation) DeletedUnixCleared() bool {
	_, ok := m.clearedFields[discovery.FieldDeletedUnix]
	return ok
}

// ResetDeletedUnix resets all changes to the "deleted_unix" field.
func (m *DiscoveryMutation) ResetDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	delete(m.clearedFields, discovery.FieldDeletedUnix)
}

// SetDate sets the "date" field.
func (m *DiscoveryMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *DiscoveryMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *DiscoveryMutation) ResetDate() {
	m.date = nil
}

// SetRid sets the "rid" field.
func (m *DiscoveryMutation) SetRid(s string) {
	m.rid = &s
}

// Rid returns the value of the "rid" field in the mutation.
func (m *DiscoveryMutation) Rid() (r string, exists bool) {
	v := m.rid
	if v == nil {
		return
	}
	return *v, true
}

// OldRid returns the old "rid" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldRid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRid: %w", err)
	}
	return oldValue.Rid, nil
}

// ResetRid resets all changes to the "rid" field.
func (m *DiscoveryMutation) ResetRid() {
	m.rid = nil
}

// SetTitle sets the "title" field.
func (m *DiscoveryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DiscoveryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DiscoveryMutation) ResetTitle() {
	m.title = nil
}

// SetDetail sets the "detail" field.
func (m *DiscoveryMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *DiscoveryMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *DiscoveryMutation) ResetDetail() {
	m.detail = nil
}

// SetMtype sets the "mtype" field.
func (m *DiscoveryMutation) SetMtype(d discovery.Mtype) {
	m.mtype = &d
}

// Mtype returns the value of the "mtype" field in the mutation.
func (m *DiscoveryMutation) Mtype() (r discovery.Mtype, exists bool) {
	v := m.mtype
	if v == nil {
		return
	}
	return *v, true
}

// OldMtype returns the old "mtype" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldMtype(ctx context.Context) (v discovery.Mtype, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMtype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMtype: %w", err)
	}
	return oldValue.Mtype, nil
}

// ResetMtype resets all changes to the "mtype" field.
func (m *DiscoveryMutation) ResetMtype() {
	m.mtype = nil
}

// SetLinks sets the "links" field.
func (m *DiscoveryMutation) SetLinks(s []string) {
	m.links = &s
}

// Links returns the value of the "links" field in the mutation.
func (m *DiscoveryMutation) Links() (r []string, exists bool) {
	v := m.links
	if v == nil {
		return
	}
	return *v, true
}

// OldLinks returns the old "links" field's value of the Discovery entity.
// If the Discovery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryMutation) OldLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinks: %w", err)
	}
	return oldValue.Links, nil
}

// ResetLinks resets all changes to the "links" field.
func (m *DiscoveryMutation) ResetLinks() {
	m.links = nil
}

// Where appends a list predicates to the DiscoveryMutation builder.
func (m *DiscoveryMutation) Where(ps ...predicate.Discovery) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DiscoveryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Discovery).
func (m *DiscoveryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscoveryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_unix != nil {
		fields = append(fields, discovery.FieldCreatedUnix)
	}
	if m.updated_unix != nil {
		fields = append(fields, discovery.FieldUpdatedUnix)
	}
	if m.deleted_unix != nil {
		fields = append(fields, discovery.FieldDeletedUnix)
	}
	if m.date != nil {
		fields = append(fields, discovery.FieldDate)
	}
	if m.rid != nil {
		fields = append(fields, discovery.FieldRid)
	}
	if m.title != nil {
		fields = append(fields, discovery.FieldTitle)
	}
	if m.detail != nil {
		fields = append(fields, discovery.FieldDetail)
	}
	if m.mtype != nil {
		fields = append(fields, discovery.FieldMtype)
	}
	if m.links != nil {
		fields = append(fields, discovery.FieldLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscoveryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discovery.FieldCreatedUnix:
		return m.CreatedUnix()
	case discovery.FieldUpdatedUnix:
		return m.UpdatedUnix()
	case discovery.FieldDeletedUnix:
		return m.DeletedUnix()
	case discovery.FieldDate:
		return m.Date()
	case discovery.FieldRid:
		return m.Rid()
	case discovery.FieldTitle:
		return m.Title()
	case discovery.FieldDetail:
		return m.Detail()
	case discovery.FieldMtype:
		return m.Mtype()
	case discovery.FieldLinks:
		return m.Links()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscoveryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discovery.FieldCreatedUnix:
		return m.OldCreatedUnix(ctx)
	case discovery.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	case discovery.FieldDeletedUnix:
		return m.OldDeletedUnix(ctx)
	case discovery.FieldDate:
		return m.OldDate(ctx)
	case discovery.FieldRid:
		return m.OldRid(ctx)
	case discovery.FieldTitle:
		return m.OldTitle(ctx)
	case discovery.FieldDetail:
		return m.OldDetail(ctx)
	case discovery.FieldMtype:
		return m.OldMtype(ctx)
	case discovery.FieldLinks:
		return m.OldLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Discovery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discovery.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedUnix(v)
		return nil
	case discovery.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	case discovery.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedUnix(v)
		return nil
	case discovery.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case discovery.FieldRid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case discovery.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case discovery.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case discovery.FieldMtype:
		v, ok := value.(discovery.Mtype)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMtype(v)
		return nil
	case discovery.FieldLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Discovery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscoveryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_unix != nil {
		fields = append(fields, discovery.FieldCreatedUnix)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, discovery.FieldUpdatedUnix)
	}
	if m.adddeleted_unix != nil {
		fields = append(fields, discovery.FieldDeletedUnix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscoveryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case discovery.FieldCreatedUnix:
		return m.AddedCreatedUnix()
	case discovery.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	case discovery.FieldDeletedUnix:
		return m.AddedDeletedUnix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case discovery.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedUnix(v)
		return nil
	case discovery.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	case discovery.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedUnix(v)
		return nil
	}
	return fmt.Errorf("unknown Discovery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscoveryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discovery.FieldDeletedUnix) {
		fields = append(fields, discovery.FieldDeletedUnix)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscoveryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscoveryMutation) ClearField(name string) error {
	switch name {
	case discovery.FieldDeletedUnix:
		m.ClearDeletedUnix()
		return nil
	}
	return fmt.Errorf("unknown Discovery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscoveryMutation) ResetField(name string) error {
	switch name {
	case discovery.FieldCreatedUnix:
		m.ResetCreatedUnix()
		return nil
	case discovery.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	case discovery.FieldDeletedUnix:
		m.ResetDeletedUnix()
		return nil
	case discovery.FieldDate:
		m.ResetDate()
		return nil
	case discovery.FieldRid:
		m.ResetRid()
		return nil
	case discovery.FieldTitle:
		m.ResetTitle()
		return nil
	case discovery.FieldDetail:
		m.ResetDetail()
		return nil
	case discovery.FieldMtype:
		m.ResetMtype()
		return nil
	case discovery.FieldLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown Discovery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscoveryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscoveryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscoveryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscoveryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscoveryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscoveryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscoveryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Discovery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscoveryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Discovery edge %s", name)
}

// InformationV1Mutation represents an operation that mutates the InformationV1 nodes in the graph.
type InformationV1Mutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_unix       *int64
	addcreated_unix    *int64
	updated_unix       *int64
	addupdated_unix    *int64
	deleted_unix       *int64
	adddeleted_unix    *int64
	root               *string
	thumb              *string
	thumb_path         *string
	poster             *string
	poster_path        *string
	media              *string
	media_path         *string
	media_index        *string
	frames             *string
	frames_path        *string
	frames_particulars *[]schema.SkipFrame
	title              *string
	video_no           *string
	intro              *string
	alias              *[]string
	role               *[]string
	director           *string
	systematics        *string
	producer           *string
	publisher          *string
	sort_type          *string
	caption            *string
	group              *string
	index              *string
	release_date       *string
	format             *string
	series             *string
	tags               *[]string
	length             *string
	sample             *[]string
	uncensored         *string
	season             *string
	total_episode      *string
	episode            *string
	language           *string
	sharpness          *string
	watermark          *bool
	permission         *informationv1.Permission
	sign               *string
	total_blocks       *int
	addtotal_blocks    *int
	clearedFields      map[string]struct{}
	top_lists          map[uuid.UUID]struct{}
	removedtop_lists   map[uuid.UUID]struct{}
	clearedtop_lists   bool
	channel            *uuid.UUID
	clearedchannel     bool
	done               bool
	oldValue           func(context.Context) (*InformationV1, error)
	predicates         []predicate.InformationV1
}

var _ ent.Mutation = (*InformationV1Mutation)(nil)

// informationv1Option allows management of the mutation configuration using functional options.
type informationv1Option func(*InformationV1Mutation)

// newInformationV1Mutation creates new mutation for the InformationV1 entity.
func newInformationV1Mutation(c config, op Op, opts ...informationv1Option) *InformationV1Mutation {
	m := &InformationV1Mutation{
		config:        c,
		op:            op,
		typ:           TypeInformationV1,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInformationV1ID sets the ID field of the mutation.
func withInformationV1ID(id uuid.UUID) informationv1Option {
	return func(m *InformationV1Mutation) {
		var (
			err   error
			once  sync.Once
			value *InformationV1
		)
		m.oldValue = func(ctx context.Context) (*InformationV1, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InformationV1.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInformationV1 sets the old InformationV1 of the mutation.
func withInformationV1(node *InformationV1) informationv1Option {
	return func(m *InformationV1Mutation) {
		m.oldValue = func(context.Context) (*InformationV1, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InformationV1Mutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InformationV1Mutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InformationV1 entities.
func (m *InformationV1Mutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InformationV1Mutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InformationV1Mutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InformationV1.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedUnix sets the "created_unix" field.
func (m *InformationV1Mutation) SetCreatedUnix(i int64) {
	m.created_unix = &i
	m.addcreated_unix = nil
}

// CreatedUnix returns the value of the "created_unix" field in the mutation.
func (m *InformationV1Mutation) CreatedUnix() (r int64, exists bool) {
	v := m.created_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedUnix returns the old "created_unix" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldCreatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedUnix: %w", err)
	}
	return oldValue.CreatedUnix, nil
}

// AddCreatedUnix adds i to the "created_unix" field.
func (m *InformationV1Mutation) AddCreatedUnix(i int64) {
	if m.addcreated_unix != nil {
		*m.addcreated_unix += i
	} else {
		m.addcreated_unix = &i
	}
}

// AddedCreatedUnix returns the value that was added to the "created_unix" field in this mutation.
func (m *InformationV1Mutation) AddedCreatedUnix() (r int64, exists bool) {
	v := m.addcreated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedUnix resets all changes to the "created_unix" field.
func (m *InformationV1Mutation) ResetCreatedUnix() {
	m.created_unix = nil
	m.addcreated_unix = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *InformationV1Mutation) SetUpdatedUnix(i int64) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *InformationV1Mutation) UpdatedUnix() (r int64, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldUpdatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *InformationV1Mutation) AddUpdatedUnix(i int64) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *InformationV1Mutation) AddedUpdatedUnix() (r int64, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *InformationV1Mutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// SetDeletedUnix sets the "deleted_unix" field.
func (m *InformationV1Mutation) SetDeletedUnix(i int64) {
	m.deleted_unix = &i
	m.adddeleted_unix = nil
}

// DeletedUnix returns the value of the "deleted_unix" field in the mutation.
func (m *InformationV1Mutation) DeletedUnix() (r int64, exists bool) {
	v := m.deleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedUnix returns the old "deleted_unix" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldDeletedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedUnix: %w", err)
	}
	return oldValue.DeletedUnix, nil
}

// AddDeletedUnix adds i to the "deleted_unix" field.
func (m *InformationV1Mutation) AddDeletedUnix(i int64) {
	if m.adddeleted_unix != nil {
		*m.adddeleted_unix += i
	} else {
		m.adddeleted_unix = &i
	}
}

// AddedDeletedUnix returns the value that was added to the "deleted_unix" field in this mutation.
func (m *InformationV1Mutation) AddedDeletedUnix() (r int64, exists bool) {
	v := m.adddeleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedUnix clears the value of the "deleted_unix" field.
func (m *InformationV1Mutation) ClearDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	m.clearedFields[informationv1.FieldDeletedUnix] = struct{}{}
}

// DeletedUnixCleared returns if the "deleted_unix" field was cleared in this mutation.
func (m *InformationV1Mutation) DeletedUnixCleared() bool {
	_, ok := m.clearedFields[informationv1.FieldDeletedUnix]
	return ok
}

// ResetDeletedUnix resets all changes to the "deleted_unix" field.
func (m *InformationV1Mutation) ResetDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	delete(m.clearedFields, informationv1.FieldDeletedUnix)
}

// SetChannelID sets the "channel_id" field.
func (m *InformationV1Mutation) SetChannelID(u uuid.UUID) {
	m.channel = &u
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *InformationV1Mutation) ChannelID() (r uuid.UUID, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldChannelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *InformationV1Mutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[informationv1.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *InformationV1Mutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[informationv1.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *InformationV1Mutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, informationv1.FieldChannelID)
}

// SetRoot sets the "root" field.
func (m *InformationV1Mutation) SetRoot(s string) {
	m.root = &s
}

// Root returns the value of the "root" field in the mutation.
func (m *InformationV1Mutation) Root() (r string, exists bool) {
	v := m.root
	if v == nil {
		return
	}
	return *v, true
}

// OldRoot returns the old "root" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldRoot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoot: %w", err)
	}
	return oldValue.Root, nil
}

// ResetRoot resets all changes to the "root" field.
func (m *InformationV1Mutation) ResetRoot() {
	m.root = nil
}

// SetThumb sets the "thumb" field.
func (m *InformationV1Mutation) SetThumb(s string) {
	m.thumb = &s
}

// Thumb returns the value of the "thumb" field in the mutation.
func (m *InformationV1Mutation) Thumb() (r string, exists bool) {
	v := m.thumb
	if v == nil {
		return
	}
	return *v, true
}

// OldThumb returns the old "thumb" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldThumb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumb: %w", err)
	}
	return oldValue.Thumb, nil
}

// ResetThumb resets all changes to the "thumb" field.
func (m *InformationV1Mutation) ResetThumb() {
	m.thumb = nil
}

// SetThumbPath sets the "thumb_path" field.
func (m *InformationV1Mutation) SetThumbPath(s string) {
	m.thumb_path = &s
}

// ThumbPath returns the value of the "thumb_path" field in the mutation.
func (m *InformationV1Mutation) ThumbPath() (r string, exists bool) {
	v := m.thumb_path
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbPath returns the old "thumb_path" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldThumbPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbPath: %w", err)
	}
	return oldValue.ThumbPath, nil
}

// ResetThumbPath resets all changes to the "thumb_path" field.
func (m *InformationV1Mutation) ResetThumbPath() {
	m.thumb_path = nil
}

// SetPoster sets the "poster" field.
func (m *InformationV1Mutation) SetPoster(s string) {
	m.poster = &s
}

// Poster returns the value of the "poster" field in the mutation.
func (m *InformationV1Mutation) Poster() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPoster returns the old "poster" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldPoster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoster: %w", err)
	}
	return oldValue.Poster, nil
}

// ResetPoster resets all changes to the "poster" field.
func (m *InformationV1Mutation) ResetPoster() {
	m.poster = nil
}

// SetPosterPath sets the "poster_path" field.
func (m *InformationV1Mutation) SetPosterPath(s string) {
	m.poster_path = &s
}

// PosterPath returns the value of the "poster_path" field in the mutation.
func (m *InformationV1Mutation) PosterPath() (r string, exists bool) {
	v := m.poster_path
	if v == nil {
		return
	}
	return *v, true
}

// OldPosterPath returns the old "poster_path" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldPosterPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosterPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosterPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosterPath: %w", err)
	}
	return oldValue.PosterPath, nil
}

// ResetPosterPath resets all changes to the "poster_path" field.
func (m *InformationV1Mutation) ResetPosterPath() {
	m.poster_path = nil
}

// SetMedia sets the "media" field.
func (m *InformationV1Mutation) SetMedia(s string) {
	m.media = &s
}

// Media returns the value of the "media" field in the mutation.
func (m *InformationV1Mutation) Media() (r string, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMedia returns the old "media" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldMedia(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedia: %w", err)
	}
	return oldValue.Media, nil
}

// ResetMedia resets all changes to the "media" field.
func (m *InformationV1Mutation) ResetMedia() {
	m.media = nil
}

// SetMediaPath sets the "media_path" field.
func (m *InformationV1Mutation) SetMediaPath(s string) {
	m.media_path = &s
}

// MediaPath returns the value of the "media_path" field in the mutation.
func (m *InformationV1Mutation) MediaPath() (r string, exists bool) {
	v := m.media_path
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaPath returns the old "media_path" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldMediaPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaPath: %w", err)
	}
	return oldValue.MediaPath, nil
}

// ResetMediaPath resets all changes to the "media_path" field.
func (m *InformationV1Mutation) ResetMediaPath() {
	m.media_path = nil
}

// SetMediaIndex sets the "media_index" field.
func (m *InformationV1Mutation) SetMediaIndex(s string) {
	m.media_index = &s
}

// MediaIndex returns the value of the "media_index" field in the mutation.
func (m *InformationV1Mutation) MediaIndex() (r string, exists bool) {
	v := m.media_index
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaIndex returns the old "media_index" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldMediaIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaIndex: %w", err)
	}
	return oldValue.MediaIndex, nil
}

// ResetMediaIndex resets all changes to the "media_index" field.
func (m *InformationV1Mutation) ResetMediaIndex() {
	m.media_index = nil
}

// SetFrames sets the "frames" field.
func (m *InformationV1Mutation) SetFrames(s string) {
	m.frames = &s
}

// Frames returns the value of the "frames" field in the mutation.
func (m *InformationV1Mutation) Frames() (r string, exists bool) {
	v := m.frames
	if v == nil {
		return
	}
	return *v, true
}

// OldFrames returns the old "frames" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldFrames(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrames: %w", err)
	}
	return oldValue.Frames, nil
}

// ResetFrames resets all changes to the "frames" field.
func (m *InformationV1Mutation) ResetFrames() {
	m.frames = nil
}

// SetFramesPath sets the "frames_path" field.
func (m *InformationV1Mutation) SetFramesPath(s string) {
	m.frames_path = &s
}

// FramesPath returns the value of the "frames_path" field in the mutation.
func (m *InformationV1Mutation) FramesPath() (r string, exists bool) {
	v := m.frames_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFramesPath returns the old "frames_path" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldFramesPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFramesPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFramesPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFramesPath: %w", err)
	}
	return oldValue.FramesPath, nil
}

// ResetFramesPath resets all changes to the "frames_path" field.
func (m *InformationV1Mutation) ResetFramesPath() {
	m.frames_path = nil
}

// SetFramesParticulars sets the "frames_particulars" field.
func (m *InformationV1Mutation) SetFramesParticulars(sf []schema.SkipFrame) {
	m.frames_particulars = &sf
}

// FramesParticulars returns the value of the "frames_particulars" field in the mutation.
func (m *InformationV1Mutation) FramesParticulars() (r []schema.SkipFrame, exists bool) {
	v := m.frames_particulars
	if v == nil {
		return
	}
	return *v, true
}

// OldFramesParticulars returns the old "frames_particulars" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldFramesParticulars(ctx context.Context) (v []schema.SkipFrame, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFramesParticulars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFramesParticulars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFramesParticulars: %w", err)
	}
	return oldValue.FramesParticulars, nil
}

// ClearFramesParticulars clears the value of the "frames_particulars" field.
func (m *InformationV1Mutation) ClearFramesParticulars() {
	m.frames_particulars = nil
	m.clearedFields[informationv1.FieldFramesParticulars] = struct{}{}
}

// FramesParticularsCleared returns if the "frames_particulars" field was cleared in this mutation.
func (m *InformationV1Mutation) FramesParticularsCleared() bool {
	_, ok := m.clearedFields[informationv1.FieldFramesParticulars]
	return ok
}

// ResetFramesParticulars resets all changes to the "frames_particulars" field.
func (m *InformationV1Mutation) ResetFramesParticulars() {
	m.frames_particulars = nil
	delete(m.clearedFields, informationv1.FieldFramesParticulars)
}

// SetTitle sets the "title" field.
func (m *InformationV1Mutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *InformationV1Mutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *InformationV1Mutation) ResetTitle() {
	m.title = nil
}

// SetVideoNo sets the "video_no" field.
func (m *InformationV1Mutation) SetVideoNo(s string) {
	m.video_no = &s
}

// VideoNo returns the value of the "video_no" field in the mutation.
func (m *InformationV1Mutation) VideoNo() (r string, exists bool) {
	v := m.video_no
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoNo returns the old "video_no" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldVideoNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoNo: %w", err)
	}
	return oldValue.VideoNo, nil
}

// ResetVideoNo resets all changes to the "video_no" field.
func (m *InformationV1Mutation) ResetVideoNo() {
	m.video_no = nil
}

// SetIntro sets the "intro" field.
func (m *InformationV1Mutation) SetIntro(s string) {
	m.intro = &s
}

// Intro returns the value of the "intro" field in the mutation.
func (m *InformationV1Mutation) Intro() (r string, exists bool) {
	v := m.intro
	if v == nil {
		return
	}
	return *v, true
}

// OldIntro returns the old "intro" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldIntro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntro: %w", err)
	}
	return oldValue.Intro, nil
}

// ResetIntro resets all changes to the "intro" field.
func (m *InformationV1Mutation) ResetIntro() {
	m.intro = nil
}

// SetAlias sets the "alias" field.
func (m *InformationV1Mutation) SetAlias(s []string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *InformationV1Mutation) Alias() (r []string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldAlias(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *InformationV1Mutation) ResetAlias() {
	m.alias = nil
}

// SetRole sets the "role" field.
func (m *InformationV1Mutation) SetRole(s []string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *InformationV1Mutation) Role() (r []string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldRole(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *InformationV1Mutation) ResetRole() {
	m.role = nil
}

// SetDirector sets the "director" field.
func (m *InformationV1Mutation) SetDirector(s string) {
	m.director = &s
}

// Director returns the value of the "director" field in the mutation.
func (m *InformationV1Mutation) Director() (r string, exists bool) {
	v := m.director
	if v == nil {
		return
	}
	return *v, true
}

// OldDirector returns the old "director" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldDirector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirector: %w", err)
	}
	return oldValue.Director, nil
}

// ResetDirector resets all changes to the "director" field.
func (m *InformationV1Mutation) ResetDirector() {
	m.director = nil
}

// SetSystematics sets the "systematics" field.
func (m *InformationV1Mutation) SetSystematics(s string) {
	m.systematics = &s
}

// Systematics returns the value of the "systematics" field in the mutation.
func (m *InformationV1Mutation) Systematics() (r string, exists bool) {
	v := m.systematics
	if v == nil {
		return
	}
	return *v, true
}

// OldSystematics returns the old "systematics" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSystematics(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystematics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystematics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystematics: %w", err)
	}
	return oldValue.Systematics, nil
}

// ResetSystematics resets all changes to the "systematics" field.
func (m *InformationV1Mutation) ResetSystematics() {
	m.systematics = nil
}

// SetProducer sets the "producer" field.
func (m *InformationV1Mutation) SetProducer(s string) {
	m.producer = &s
}

// Producer returns the value of the "producer" field in the mutation.
func (m *InformationV1Mutation) Producer() (r string, exists bool) {
	v := m.producer
	if v == nil {
		return
	}
	return *v, true
}

// OldProducer returns the old "producer" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldProducer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProducer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProducer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProducer: %w", err)
	}
	return oldValue.Producer, nil
}

// ResetProducer resets all changes to the "producer" field.
func (m *InformationV1Mutation) ResetProducer() {
	m.producer = nil
}

// SetPublisher sets the "publisher" field.
func (m *InformationV1Mutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *InformationV1Mutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *InformationV1Mutation) ResetPublisher() {
	m.publisher = nil
}

// SetSortType sets the "sort_type" field.
func (m *InformationV1Mutation) SetSortType(s string) {
	m.sort_type = &s
}

// SortType returns the value of the "sort_type" field in the mutation.
func (m *InformationV1Mutation) SortType() (r string, exists bool) {
	v := m.sort_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSortType returns the old "sort_type" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSortType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortType: %w", err)
	}
	return oldValue.SortType, nil
}

// ResetSortType resets all changes to the "sort_type" field.
func (m *InformationV1Mutation) ResetSortType() {
	m.sort_type = nil
}

// SetCaption sets the "caption" field.
func (m *InformationV1Mutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *InformationV1Mutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldCaption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ResetCaption resets all changes to the "caption" field.
func (m *InformationV1Mutation) ResetCaption() {
	m.caption = nil
}

// SetGroup sets the "group" field.
func (m *InformationV1Mutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *InformationV1Mutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *InformationV1Mutation) ResetGroup() {
	m.group = nil
}

// SetIndex sets the "index" field.
func (m *InformationV1Mutation) SetIndex(s string) {
	m.index = &s
}

// Index returns the value of the "index" field in the mutation.
func (m *InformationV1Mutation) Index() (r string, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// ResetIndex resets all changes to the "index" field.
func (m *InformationV1Mutation) ResetIndex() {
	m.index = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *InformationV1Mutation) SetReleaseDate(s string) {
	m.release_date = &s
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *InformationV1Mutation) ReleaseDate() (r string, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldReleaseDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *InformationV1Mutation) ResetReleaseDate() {
	m.release_date = nil
}

// SetFormat sets the "format" field.
func (m *InformationV1Mutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *InformationV1Mutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *InformationV1Mutation) ResetFormat() {
	m.format = nil
}

// SetSeries sets the "series" field.
func (m *InformationV1Mutation) SetSeries(s string) {
	m.series = &s
}

// Series returns the value of the "series" field in the mutation.
func (m *InformationV1Mutation) Series() (r string, exists bool) {
	v := m.series
	if v == nil {
		return
	}
	return *v, true
}

// OldSeries returns the old "series" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSeries(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeries: %w", err)
	}
	return oldValue.Series, nil
}

// ResetSeries resets all changes to the "series" field.
func (m *InformationV1Mutation) ResetSeries() {
	m.series = nil
}

// SetTags sets the "tags" field.
func (m *InformationV1Mutation) SetTags(s []string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *InformationV1Mutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *InformationV1Mutation) ResetTags() {
	m.tags = nil
}

// SetLength sets the "length" field.
func (m *InformationV1Mutation) SetLength(s string) {
	m.length = &s
}

// Length returns the value of the "length" field in the mutation.
func (m *InformationV1Mutation) Length() (r string, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldLength(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// ResetLength resets all changes to the "length" field.
func (m *InformationV1Mutation) ResetLength() {
	m.length = nil
}

// SetSample sets the "sample" field.
func (m *InformationV1Mutation) SetSample(s []string) {
	m.sample = &s
}

// Sample returns the value of the "sample" field in the mutation.
func (m *InformationV1Mutation) Sample() (r []string, exists bool) {
	v := m.sample
	if v == nil {
		return
	}
	return *v, true
}

// OldSample returns the old "sample" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSample(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSample is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSample requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSample: %w", err)
	}
	return oldValue.Sample, nil
}

// ResetSample resets all changes to the "sample" field.
func (m *InformationV1Mutation) ResetSample() {
	m.sample = nil
}

// SetUncensored sets the "uncensored" field.
func (m *InformationV1Mutation) SetUncensored(s string) {
	m.uncensored = &s
}

// Uncensored returns the value of the "uncensored" field in the mutation.
func (m *InformationV1Mutation) Uncensored() (r string, exists bool) {
	v := m.uncensored
	if v == nil {
		return
	}
	return *v, true
}

// OldUncensored returns the old "uncensored" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldUncensored(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUncensored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUncensored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUncensored: %w", err)
	}
	return oldValue.Uncensored, nil
}

// ResetUncensored resets all changes to the "uncensored" field.
func (m *InformationV1Mutation) ResetUncensored() {
	m.uncensored = nil
}

// SetSeason sets the "season" field.
func (m *InformationV1Mutation) SetSeason(s string) {
	m.season = &s
}

// Season returns the value of the "season" field in the mutation.
func (m *InformationV1Mutation) Season() (r string, exists bool) {
	v := m.season
	if v == nil {
		return
	}
	return *v, true
}

// OldSeason returns the old "season" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSeason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeason: %w", err)
	}
	return oldValue.Season, nil
}

// ResetSeason resets all changes to the "season" field.
func (m *InformationV1Mutation) ResetSeason() {
	m.season = nil
}

// SetTotalEpisode sets the "total_episode" field.
func (m *InformationV1Mutation) SetTotalEpisode(s string) {
	m.total_episode = &s
}

// TotalEpisode returns the value of the "total_episode" field in the mutation.
func (m *InformationV1Mutation) TotalEpisode() (r string, exists bool) {
	v := m.total_episode
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalEpisode returns the old "total_episode" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldTotalEpisode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalEpisode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalEpisode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalEpisode: %w", err)
	}
	return oldValue.TotalEpisode, nil
}

// ResetTotalEpisode resets all changes to the "total_episode" field.
func (m *InformationV1Mutation) ResetTotalEpisode() {
	m.total_episode = nil
}

// SetEpisode sets the "episode" field.
func (m *InformationV1Mutation) SetEpisode(s string) {
	m.episode = &s
}

// Episode returns the value of the "episode" field in the mutation.
func (m *InformationV1Mutation) Episode() (r string, exists bool) {
	v := m.episode
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisode returns the old "episode" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldEpisode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisode: %w", err)
	}
	return oldValue.Episode, nil
}

// ResetEpisode resets all changes to the "episode" field.
func (m *InformationV1Mutation) ResetEpisode() {
	m.episode = nil
}

// SetLanguage sets the "language" field.
func (m *InformationV1Mutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *InformationV1Mutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *InformationV1Mutation) ResetLanguage() {
	m.language = nil
}

// SetSharpness sets the "sharpness" field.
func (m *InformationV1Mutation) SetSharpness(s string) {
	m.sharpness = &s
}

// Sharpness returns the value of the "sharpness" field in the mutation.
func (m *InformationV1Mutation) Sharpness() (r string, exists bool) {
	v := m.sharpness
	if v == nil {
		return
	}
	return *v, true
}

// OldSharpness returns the old "sharpness" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSharpness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharpness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharpness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharpness: %w", err)
	}
	return oldValue.Sharpness, nil
}

// ResetSharpness resets all changes to the "sharpness" field.
func (m *InformationV1Mutation) ResetSharpness() {
	m.sharpness = nil
}

// SetWatermark sets the "watermark" field.
func (m *InformationV1Mutation) SetWatermark(b bool) {
	m.watermark = &b
}

// Watermark returns the value of the "watermark" field in the mutation.
func (m *InformationV1Mutation) Watermark() (r bool, exists bool) {
	v := m.watermark
	if v == nil {
		return
	}
	return *v, true
}

// OldWatermark returns the old "watermark" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldWatermark(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatermark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatermark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatermark: %w", err)
	}
	return oldValue.Watermark, nil
}

// ResetWatermark resets all changes to the "watermark" field.
func (m *InformationV1Mutation) ResetWatermark() {
	m.watermark = nil
}

// SetPermission sets the "permission" field.
func (m *InformationV1Mutation) SetPermission(i informationv1.Permission) {
	m.permission = &i
}

// Permission returns the value of the "permission" field in the mutation.
func (m *InformationV1Mutation) Permission() (r informationv1.Permission, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldPermission(ctx context.Context) (v informationv1.Permission, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ResetPermission resets all changes to the "permission" field.
func (m *InformationV1Mutation) ResetPermission() {
	m.permission = nil
}

// SetSign sets the "sign" field.
func (m *InformationV1Mutation) SetSign(s string) {
	m.sign = &s
}

// Sign returns the value of the "sign" field in the mutation.
func (m *InformationV1Mutation) Sign() (r string, exists bool) {
	v := m.sign
	if v == nil {
		return
	}
	return *v, true
}

// OldSign returns the old "sign" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSign: %w", err)
	}
	return oldValue.Sign, nil
}

// ClearSign clears the value of the "sign" field.
func (m *InformationV1Mutation) ClearSign() {
	m.sign = nil
	m.clearedFields[informationv1.FieldSign] = struct{}{}
}

// SignCleared returns if the "sign" field was cleared in this mutation.
func (m *InformationV1Mutation) SignCleared() bool {
	_, ok := m.clearedFields[informationv1.FieldSign]
	return ok
}

// ResetSign resets all changes to the "sign" field.
func (m *InformationV1Mutation) ResetSign() {
	m.sign = nil
	delete(m.clearedFields, informationv1.FieldSign)
}

// SetTotalBlocks sets the "total_blocks" field.
func (m *InformationV1Mutation) SetTotalBlocks(i int) {
	m.total_blocks = &i
	m.addtotal_blocks = nil
}

// TotalBlocks returns the value of the "total_blocks" field in the mutation.
func (m *InformationV1Mutation) TotalBlocks() (r int, exists bool) {
	v := m.total_blocks
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBlocks returns the old "total_blocks" field's value of the InformationV1 entity.
// If the InformationV1 object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationV1Mutation) OldTotalBlocks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalBlocks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalBlocks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBlocks: %w", err)
	}
	return oldValue.TotalBlocks, nil
}

// AddTotalBlocks adds i to the "total_blocks" field.
func (m *InformationV1Mutation) AddTotalBlocks(i int) {
	if m.addtotal_blocks != nil {
		*m.addtotal_blocks += i
	} else {
		m.addtotal_blocks = &i
	}
}

// AddedTotalBlocks returns the value that was added to the "total_blocks" field in this mutation.
func (m *InformationV1Mutation) AddedTotalBlocks() (r int, exists bool) {
	v := m.addtotal_blocks
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalBlocks resets all changes to the "total_blocks" field.
func (m *InformationV1Mutation) ResetTotalBlocks() {
	m.total_blocks = nil
	m.addtotal_blocks = nil
}

// AddTopListIDs adds the "top_lists" edge to the TopList entity by ids.
func (m *InformationV1Mutation) AddTopListIDs(ids ...uuid.UUID) {
	if m.top_lists == nil {
		m.top_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.top_lists[ids[i]] = struct{}{}
	}
}

// ClearTopLists clears the "top_lists" edge to the TopList entity.
func (m *InformationV1Mutation) ClearTopLists() {
	m.clearedtop_lists = true
}

// TopListsCleared reports if the "top_lists" edge to the TopList entity was cleared.
func (m *InformationV1Mutation) TopListsCleared() bool {
	return m.clearedtop_lists
}

// RemoveTopListIDs removes the "top_lists" edge to the TopList entity by IDs.
func (m *InformationV1Mutation) RemoveTopListIDs(ids ...uuid.UUID) {
	if m.removedtop_lists == nil {
		m.removedtop_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.top_lists, ids[i])
		m.removedtop_lists[ids[i]] = struct{}{}
	}
}

// RemovedTopLists returns the removed IDs of the "top_lists" edge to the TopList entity.
func (m *InformationV1Mutation) RemovedTopListsIDs() (ids []uuid.UUID) {
	for id := range m.removedtop_lists {
		ids = append(ids, id)
	}
	return
}

// TopListsIDs returns the "top_lists" edge IDs in the mutation.
func (m *InformationV1Mutation) TopListsIDs() (ids []uuid.UUID) {
	for id := range m.top_lists {
		ids = append(ids, id)
	}
	return
}

// ResetTopLists resets all changes to the "top_lists" edge.
func (m *InformationV1Mutation) ResetTopLists() {
	m.top_lists = nil
	m.clearedtop_lists = false
	m.removedtop_lists = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *InformationV1Mutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *InformationV1Mutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *InformationV1Mutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *InformationV1Mutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the InformationV1Mutation builder.
func (m *InformationV1Mutation) Where(ps ...predicate.InformationV1) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InformationV1Mutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InformationV1).
func (m *InformationV1Mutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InformationV1Mutation) Fields() []string {
	fields := make([]string, 0, 44)
	if m.created_unix != nil {
		fields = append(fields, informationv1.FieldCreatedUnix)
	}
	if m.updated_unix != nil {
		fields = append(fields, informationv1.FieldUpdatedUnix)
	}
	if m.deleted_unix != nil {
		fields = append(fields, informationv1.FieldDeletedUnix)
	}
	if m.channel != nil {
		fields = append(fields, informationv1.FieldChannelID)
	}
	if m.root != nil {
		fields = append(fields, informationv1.FieldRoot)
	}
	if m.thumb != nil {
		fields = append(fields, informationv1.FieldThumb)
	}
	if m.thumb_path != nil {
		fields = append(fields, informationv1.FieldThumbPath)
	}
	if m.poster != nil {
		fields = append(fields, informationv1.FieldPoster)
	}
	if m.poster_path != nil {
		fields = append(fields, informationv1.FieldPosterPath)
	}
	if m.media != nil {
		fields = append(fields, informationv1.FieldMedia)
	}
	if m.media_path != nil {
		fields = append(fields, informationv1.FieldMediaPath)
	}
	if m.media_index != nil {
		fields = append(fields, informationv1.FieldMediaIndex)
	}
	if m.frames != nil {
		fields = append(fields, informationv1.FieldFrames)
	}
	if m.frames_path != nil {
		fields = append(fields, informationv1.FieldFramesPath)
	}
	if m.frames_particulars != nil {
		fields = append(fields, informationv1.FieldFramesParticulars)
	}
	if m.title != nil {
		fields = append(fields, informationv1.FieldTitle)
	}
	if m.video_no != nil {
		fields = append(fields, informationv1.FieldVideoNo)
	}
	if m.intro != nil {
		fields = append(fields, informationv1.FieldIntro)
	}
	if m.alias != nil {
		fields = append(fields, informationv1.FieldAlias)
	}
	if m.role != nil {
		fields = append(fields, informationv1.FieldRole)
	}
	if m.director != nil {
		fields = append(fields, informationv1.FieldDirector)
	}
	if m.systematics != nil {
		fields = append(fields, informationv1.FieldSystematics)
	}
	if m.producer != nil {
		fields = append(fields, informationv1.FieldProducer)
	}
	if m.publisher != nil {
		fields = append(fields, informationv1.FieldPublisher)
	}
	if m.sort_type != nil {
		fields = append(fields, informationv1.FieldSortType)
	}
	if m.caption != nil {
		fields = append(fields, informationv1.FieldCaption)
	}
	if m.group != nil {
		fields = append(fields, informationv1.FieldGroup)
	}
	if m.index != nil {
		fields = append(fields, informationv1.FieldIndex)
	}
	if m.release_date != nil {
		fields = append(fields, informationv1.FieldReleaseDate)
	}
	if m.format != nil {
		fields = append(fields, informationv1.FieldFormat)
	}
	if m.series != nil {
		fields = append(fields, informationv1.FieldSeries)
	}
	if m.tags != nil {
		fields = append(fields, informationv1.FieldTags)
	}
	if m.length != nil {
		fields = append(fields, informationv1.FieldLength)
	}
	if m.sample != nil {
		fields = append(fields, informationv1.FieldSample)
	}
	if m.uncensored != nil {
		fields = append(fields, informationv1.FieldUncensored)
	}
	if m.season != nil {
		fields = append(fields, informationv1.FieldSeason)
	}
	if m.total_episode != nil {
		fields = append(fields, informationv1.FieldTotalEpisode)
	}
	if m.episode != nil {
		fields = append(fields, informationv1.FieldEpisode)
	}
	if m.language != nil {
		fields = append(fields, informationv1.FieldLanguage)
	}
	if m.sharpness != nil {
		fields = append(fields, informationv1.FieldSharpness)
	}
	if m.watermark != nil {
		fields = append(fields, informationv1.FieldWatermark)
	}
	if m.permission != nil {
		fields = append(fields, informationv1.FieldPermission)
	}
	if m.sign != nil {
		fields = append(fields, informationv1.FieldSign)
	}
	if m.total_blocks != nil {
		fields = append(fields, informationv1.FieldTotalBlocks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InformationV1Mutation) Field(name string) (ent.Value, bool) {
	switch name {
	case informationv1.FieldCreatedUnix:
		return m.CreatedUnix()
	case informationv1.FieldUpdatedUnix:
		return m.UpdatedUnix()
	case informationv1.FieldDeletedUnix:
		return m.DeletedUnix()
	case informationv1.FieldChannelID:
		return m.ChannelID()
	case informationv1.FieldRoot:
		return m.Root()
	case informationv1.FieldThumb:
		return m.Thumb()
	case informationv1.FieldThumbPath:
		return m.ThumbPath()
	case informationv1.FieldPoster:
		return m.Poster()
	case informationv1.FieldPosterPath:
		return m.PosterPath()
	case informationv1.FieldMedia:
		return m.Media()
	case informationv1.FieldMediaPath:
		return m.MediaPath()
	case informationv1.FieldMediaIndex:
		return m.MediaIndex()
	case informationv1.FieldFrames:
		return m.Frames()
	case informationv1.FieldFramesPath:
		return m.FramesPath()
	case informationv1.FieldFramesParticulars:
		return m.FramesParticulars()
	case informationv1.FieldTitle:
		return m.Title()
	case informationv1.FieldVideoNo:
		return m.VideoNo()
	case informationv1.FieldIntro:
		return m.Intro()
	case informationv1.FieldAlias:
		return m.Alias()
	case informationv1.FieldRole:
		return m.Role()
	case informationv1.FieldDirector:
		return m.Director()
	case informationv1.FieldSystematics:
		return m.Systematics()
	case informationv1.FieldProducer:
		return m.Producer()
	case informationv1.FieldPublisher:
		return m.Publisher()
	case informationv1.FieldSortType:
		return m.SortType()
	case informationv1.FieldCaption:
		return m.Caption()
	case informationv1.FieldGroup:
		return m.Group()
	case informationv1.FieldIndex:
		return m.Index()
	case informationv1.FieldReleaseDate:
		return m.ReleaseDate()
	case informationv1.FieldFormat:
		return m.Format()
	case informationv1.FieldSeries:
		return m.Series()
	case informationv1.FieldTags:
		return m.Tags()
	case informationv1.FieldLength:
		return m.Length()
	case informationv1.FieldSample:
		return m.Sample()
	case informationv1.FieldUncensored:
		return m.Uncensored()
	case informationv1.FieldSeason:
		return m.Season()
	case informationv1.FieldTotalEpisode:
		return m.TotalEpisode()
	case informationv1.FieldEpisode:
		return m.Episode()
	case informationv1.FieldLanguage:
		return m.Language()
	case informationv1.FieldSharpness:
		return m.Sharpness()
	case informationv1.FieldWatermark:
		return m.Watermark()
	case informationv1.FieldPermission:
		return m.Permission()
	case informationv1.FieldSign:
		return m.Sign()
	case informationv1.FieldTotalBlocks:
		return m.TotalBlocks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InformationV1Mutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case informationv1.FieldCreatedUnix:
		return m.OldCreatedUnix(ctx)
	case informationv1.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	case informationv1.FieldDeletedUnix:
		return m.OldDeletedUnix(ctx)
	case informationv1.FieldChannelID:
		return m.OldChannelID(ctx)
	case informationv1.FieldRoot:
		return m.OldRoot(ctx)
	case informationv1.FieldThumb:
		return m.OldThumb(ctx)
	case informationv1.FieldThumbPath:
		return m.OldThumbPath(ctx)
	case informationv1.FieldPoster:
		return m.OldPoster(ctx)
	case informationv1.FieldPosterPath:
		return m.OldPosterPath(ctx)
	case informationv1.FieldMedia:
		return m.OldMedia(ctx)
	case informationv1.FieldMediaPath:
		return m.OldMediaPath(ctx)
	case informationv1.FieldMediaIndex:
		return m.OldMediaIndex(ctx)
	case informationv1.FieldFrames:
		return m.OldFrames(ctx)
	case informationv1.FieldFramesPath:
		return m.OldFramesPath(ctx)
	case informationv1.FieldFramesParticulars:
		return m.OldFramesParticulars(ctx)
	case informationv1.FieldTitle:
		return m.OldTitle(ctx)
	case informationv1.FieldVideoNo:
		return m.OldVideoNo(ctx)
	case informationv1.FieldIntro:
		return m.OldIntro(ctx)
	case informationv1.FieldAlias:
		return m.OldAlias(ctx)
	case informationv1.FieldRole:
		return m.OldRole(ctx)
	case informationv1.FieldDirector:
		return m.OldDirector(ctx)
	case informationv1.FieldSystematics:
		return m.OldSystematics(ctx)
	case informationv1.FieldProducer:
		return m.OldProducer(ctx)
	case informationv1.FieldPublisher:
		return m.OldPublisher(ctx)
	case informationv1.FieldSortType:
		return m.OldSortType(ctx)
	case informationv1.FieldCaption:
		return m.OldCaption(ctx)
	case informationv1.FieldGroup:
		return m.OldGroup(ctx)
	case informationv1.FieldIndex:
		return m.OldIndex(ctx)
	case informationv1.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case informationv1.FieldFormat:
		return m.OldFormat(ctx)
	case informationv1.FieldSeries:
		return m.OldSeries(ctx)
	case informationv1.FieldTags:
		return m.OldTags(ctx)
	case informationv1.FieldLength:
		return m.OldLength(ctx)
	case informationv1.FieldSample:
		return m.OldSample(ctx)
	case informationv1.FieldUncensored:
		return m.OldUncensored(ctx)
	case informationv1.FieldSeason:
		return m.OldSeason(ctx)
	case informationv1.FieldTotalEpisode:
		return m.OldTotalEpisode(ctx)
	case informationv1.FieldEpisode:
		return m.OldEpisode(ctx)
	case informationv1.FieldLanguage:
		return m.OldLanguage(ctx)
	case informationv1.FieldSharpness:
		return m.OldSharpness(ctx)
	case informationv1.FieldWatermark:
		return m.OldWatermark(ctx)
	case informationv1.FieldPermission:
		return m.OldPermission(ctx)
	case informationv1.FieldSign:
		return m.OldSign(ctx)
	case informationv1.FieldTotalBlocks:
		return m.OldTotalBlocks(ctx)
	}
	return nil, fmt.Errorf("unknown InformationV1 field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InformationV1Mutation) SetField(name string, value ent.Value) error {
	switch name {
	case informationv1.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedUnix(v)
		return nil
	case informationv1.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	case informationv1.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedUnix(v)
		return nil
	case informationv1.FieldChannelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case informationv1.FieldRoot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoot(v)
		return nil
	case informationv1.FieldThumb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumb(v)
		return nil
	case informationv1.FieldThumbPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbPath(v)
		return nil
	case informationv1.FieldPoster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoster(v)
		return nil
	case informationv1.FieldPosterPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosterPath(v)
		return nil
	case informationv1.FieldMedia:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedia(v)
		return nil
	case informationv1.FieldMediaPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaPath(v)
		return nil
	case informationv1.FieldMediaIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaIndex(v)
		return nil
	case informationv1.FieldFrames:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrames(v)
		return nil
	case informationv1.FieldFramesPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFramesPath(v)
		return nil
	case informationv1.FieldFramesParticulars:
		v, ok := value.([]schema.SkipFrame)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFramesParticulars(v)
		return nil
	case informationv1.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case informationv1.FieldVideoNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoNo(v)
		return nil
	case informationv1.FieldIntro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntro(v)
		return nil
	case informationv1.FieldAlias:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case informationv1.FieldRole:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case informationv1.FieldDirector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirector(v)
		return nil
	case informationv1.FieldSystematics:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystematics(v)
		return nil
	case informationv1.FieldProducer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProducer(v)
		return nil
	case informationv1.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case informationv1.FieldSortType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortType(v)
		return nil
	case informationv1.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case informationv1.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case informationv1.FieldIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case informationv1.FieldReleaseDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case informationv1.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case informationv1.FieldSeries:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeries(v)
		return nil
	case informationv1.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case informationv1.FieldLength:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case informationv1.FieldSample:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSample(v)
		return nil
	case informationv1.FieldUncensored:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUncensored(v)
		return nil
	case informationv1.FieldSeason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeason(v)
		return nil
	case informationv1.FieldTotalEpisode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalEpisode(v)
		return nil
	case informationv1.FieldEpisode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisode(v)
		return nil
	case informationv1.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case informationv1.FieldSharpness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharpness(v)
		return nil
	case informationv1.FieldWatermark:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatermark(v)
		return nil
	case informationv1.FieldPermission:
		v, ok := value.(informationv1.Permission)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case informationv1.FieldSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSign(v)
		return nil
	case informationv1.FieldTotalBlocks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBlocks(v)
		return nil
	}
	return fmt.Errorf("unknown InformationV1 field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InformationV1Mutation) AddedFields() []string {
	var fields []string
	if m.addcreated_unix != nil {
		fields = append(fields, informationv1.FieldCreatedUnix)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, informationv1.FieldUpdatedUnix)
	}
	if m.adddeleted_unix != nil {
		fields = append(fields, informationv1.FieldDeletedUnix)
	}
	if m.addtotal_blocks != nil {
		fields = append(fields, informationv1.FieldTotalBlocks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InformationV1Mutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case informationv1.FieldCreatedUnix:
		return m.AddedCreatedUnix()
	case informationv1.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	case informationv1.FieldDeletedUnix:
		return m.AddedDeletedUnix()
	case informationv1.FieldTotalBlocks:
		return m.AddedTotalBlocks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InformationV1Mutation) AddField(name string, value ent.Value) error {
	switch name {
	case informationv1.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedUnix(v)
		return nil
	case informationv1.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	case informationv1.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedUnix(v)
		return nil
	case informationv1.FieldTotalBlocks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalBlocks(v)
		return nil
	}
	return fmt.Errorf("unknown InformationV1 numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InformationV1Mutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(informationv1.FieldDeletedUnix) {
		fields = append(fields, informationv1.FieldDeletedUnix)
	}
	if m.FieldCleared(informationv1.FieldChannelID) {
		fields = append(fields, informationv1.FieldChannelID)
	}
	if m.FieldCleared(informationv1.FieldFramesParticulars) {
		fields = append(fields, informationv1.FieldFramesParticulars)
	}
	if m.FieldCleared(informationv1.FieldSign) {
		fields = append(fields, informationv1.FieldSign)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InformationV1Mutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InformationV1Mutation) ClearField(name string) error {
	switch name {
	case informationv1.FieldDeletedUnix:
		m.ClearDeletedUnix()
		return nil
	case informationv1.FieldChannelID:
		m.ClearChannelID()
		return nil
	case informationv1.FieldFramesParticulars:
		m.ClearFramesParticulars()
		return nil
	case informationv1.FieldSign:
		m.ClearSign()
		return nil
	}
	return fmt.Errorf("unknown InformationV1 nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InformationV1Mutation) ResetField(name string) error {
	switch name {
	case informationv1.FieldCreatedUnix:
		m.ResetCreatedUnix()
		return nil
	case informationv1.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	case informationv1.FieldDeletedUnix:
		m.ResetDeletedUnix()
		return nil
	case informationv1.FieldChannelID:
		m.ResetChannelID()
		return nil
	case informationv1.FieldRoot:
		m.ResetRoot()
		return nil
	case informationv1.FieldThumb:
		m.ResetThumb()
		return nil
	case informationv1.FieldThumbPath:
		m.ResetThumbPath()
		return nil
	case informationv1.FieldPoster:
		m.ResetPoster()
		return nil
	case informationv1.FieldPosterPath:
		m.ResetPosterPath()
		return nil
	case informationv1.FieldMedia:
		m.ResetMedia()
		return nil
	case informationv1.FieldMediaPath:
		m.ResetMediaPath()
		return nil
	case informationv1.FieldMediaIndex:
		m.ResetMediaIndex()
		return nil
	case informationv1.FieldFrames:
		m.ResetFrames()
		return nil
	case informationv1.FieldFramesPath:
		m.ResetFramesPath()
		return nil
	case informationv1.FieldFramesParticulars:
		m.ResetFramesParticulars()
		return nil
	case informationv1.FieldTitle:
		m.ResetTitle()
		return nil
	case informationv1.FieldVideoNo:
		m.ResetVideoNo()
		return nil
	case informationv1.FieldIntro:
		m.ResetIntro()
		return nil
	case informationv1.FieldAlias:
		m.ResetAlias()
		return nil
	case informationv1.FieldRole:
		m.ResetRole()
		return nil
	case informationv1.FieldDirector:
		m.ResetDirector()
		return nil
	case informationv1.FieldSystematics:
		m.ResetSystematics()
		return nil
	case informationv1.FieldProducer:
		m.ResetProducer()
		return nil
	case informationv1.FieldPublisher:
		m.ResetPublisher()
		return nil
	case informationv1.FieldSortType:
		m.ResetSortType()
		return nil
	case informationv1.FieldCaption:
		m.ResetCaption()
		return nil
	case informationv1.FieldGroup:
		m.ResetGroup()
		return nil
	case informationv1.FieldIndex:
		m.ResetIndex()
		return nil
	case informationv1.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case informationv1.FieldFormat:
		m.ResetFormat()
		return nil
	case informationv1.FieldSeries:
		m.ResetSeries()
		return nil
	case informationv1.FieldTags:
		m.ResetTags()
		return nil
	case informationv1.FieldLength:
		m.ResetLength()
		return nil
	case informationv1.FieldSample:
		m.ResetSample()
		return nil
	case informationv1.FieldUncensored:
		m.ResetUncensored()
		return nil
	case informationv1.FieldSeason:
		m.ResetSeason()
		return nil
	case informationv1.FieldTotalEpisode:
		m.ResetTotalEpisode()
		return nil
	case informationv1.FieldEpisode:
		m.ResetEpisode()
		return nil
	case informationv1.FieldLanguage:
		m.ResetLanguage()
		return nil
	case informationv1.FieldSharpness:
		m.ResetSharpness()
		return nil
	case informationv1.FieldWatermark:
		m.ResetWatermark()
		return nil
	case informationv1.FieldPermission:
		m.ResetPermission()
		return nil
	case informationv1.FieldSign:
		m.ResetSign()
		return nil
	case informationv1.FieldTotalBlocks:
		m.ResetTotalBlocks()
		return nil
	}
	return fmt.Errorf("unknown InformationV1 field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InformationV1Mutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.top_lists != nil {
		edges = append(edges, informationv1.EdgeTopLists)
	}
	if m.channel != nil {
		edges = append(edges, informationv1.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InformationV1Mutation) AddedIDs(name string) []ent.Value {
	switch name {
	case informationv1.EdgeTopLists:
		ids := make([]ent.Value, 0, len(m.top_lists))
		for id := range m.top_lists {
			ids = append(ids, id)
		}
		return ids
	case informationv1.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InformationV1Mutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtop_lists != nil {
		edges = append(edges, informationv1.EdgeTopLists)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InformationV1Mutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case informationv1.EdgeTopLists:
		ids := make([]ent.Value, 0, len(m.removedtop_lists))
		for id := range m.removedtop_lists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InformationV1Mutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtop_lists {
		edges = append(edges, informationv1.EdgeTopLists)
	}
	if m.clearedchannel {
		edges = append(edges, informationv1.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InformationV1Mutation) EdgeCleared(name string) bool {
	switch name {
	case informationv1.EdgeTopLists:
		return m.clearedtop_lists
	case informationv1.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InformationV1Mutation) ClearEdge(name string) error {
	switch name {
	case informationv1.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown InformationV1 unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InformationV1Mutation) ResetEdge(name string) error {
	switch name {
	case informationv1.EdgeTopLists:
		m.ResetTopLists()
		return nil
	case informationv1.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown InformationV1 edge %s", name)
}

// PageMutation represents an operation that mutates the Page nodes in the graph.
type PageMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_unix      *int64
	addcreated_unix   *int64
	updated_unix      *int64
	addupdated_unix   *int64
	deleted_unix      *int64
	adddeleted_unix   *int64
	title             *string
	featured_index    *int8
	addfeatured_index *int8
	featured_content  *string
	recommend         *int64
	addrecommend      *int64
	clearedFields     map[string]struct{}
	parent            *uuid.UUID
	clearedparent     bool
	subpages          map[uuid.UUID]struct{}
	removedsubpages   map[uuid.UUID]struct{}
	clearedsubpages   bool
	top_lists         map[uuid.UUID]struct{}
	removedtop_lists  map[uuid.UUID]struct{}
	clearedtop_lists  bool
	done              bool
	oldValue          func(context.Context) (*Page, error)
	predicates        []predicate.Page
}

var _ ent.Mutation = (*PageMutation)(nil)

// pageOption allows management of the mutation configuration using functional options.
type pageOption func(*PageMutation)

// newPageMutation creates new mutation for the Page entity.
func newPageMutation(c config, op Op, opts ...pageOption) *PageMutation {
	m := &PageMutation{
		config:        c,
		op:            op,
		typ:           TypePage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageID sets the ID field of the mutation.
func withPageID(id uuid.UUID) pageOption {
	return func(m *PageMutation) {
		var (
			err   error
			once  sync.Once
			value *Page
		)
		m.oldValue = func(ctx context.Context) (*Page, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Page.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPage sets the old Page of the mutation.
func withPage(node *Page) pageOption {
	return func(m *PageMutation) {
		m.oldValue = func(context.Context) (*Page, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Page entities.
func (m *PageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Page.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedUnix sets the "created_unix" field.
func (m *PageMutation) SetCreatedUnix(i int64) {
	m.created_unix = &i
	m.addcreated_unix = nil
}

// CreatedUnix returns the value of the "created_unix" field in the mutation.
func (m *PageMutation) CreatedUnix() (r int64, exists bool) {
	v := m.created_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedUnix returns the old "created_unix" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldCreatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedUnix: %w", err)
	}
	return oldValue.CreatedUnix, nil
}

// AddCreatedUnix adds i to the "created_unix" field.
func (m *PageMutation) AddCreatedUnix(i int64) {
	if m.addcreated_unix != nil {
		*m.addcreated_unix += i
	} else {
		m.addcreated_unix = &i
	}
}

// AddedCreatedUnix returns the value that was added to the "created_unix" field in this mutation.
func (m *PageMutation) AddedCreatedUnix() (r int64, exists bool) {
	v := m.addcreated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedUnix resets all changes to the "created_unix" field.
func (m *PageMutation) ResetCreatedUnix() {
	m.created_unix = nil
	m.addcreated_unix = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *PageMutation) SetUpdatedUnix(i int64) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *PageMutation) UpdatedUnix() (r int64, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldUpdatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *PageMutation) AddUpdatedUnix(i int64) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *PageMutation) AddedUpdatedUnix() (r int64, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *PageMutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// SetDeletedUnix sets the "deleted_unix" field.
func (m *PageMutation) SetDeletedUnix(i int64) {
	m.deleted_unix = &i
	m.adddeleted_unix = nil
}

// DeletedUnix returns the value of the "deleted_unix" field in the mutation.
func (m *PageMutation) DeletedUnix() (r int64, exists bool) {
	v := m.deleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedUnix returns the old "deleted_unix" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldDeletedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedUnix: %w", err)
	}
	return oldValue.DeletedUnix, nil
}

// AddDeletedUnix adds i to the "deleted_unix" field.
func (m *PageMutation) AddDeletedUnix(i int64) {
	if m.adddeleted_unix != nil {
		*m.adddeleted_unix += i
	} else {
		m.adddeleted_unix = &i
	}
}

// AddedDeletedUnix returns the value that was added to the "deleted_unix" field in this mutation.
func (m *PageMutation) AddedDeletedUnix() (r int64, exists bool) {
	v := m.adddeleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedUnix clears the value of the "deleted_unix" field.
func (m *PageMutation) ClearDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	m.clearedFields[page.FieldDeletedUnix] = struct{}{}
}

// DeletedUnixCleared returns if the "deleted_unix" field was cleared in this mutation.
func (m *PageMutation) DeletedUnixCleared() bool {
	_, ok := m.clearedFields[page.FieldDeletedUnix]
	return ok
}

// ResetDeletedUnix resets all changes to the "deleted_unix" field.
func (m *PageMutation) ResetDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	delete(m.clearedFields, page.FieldDeletedUnix)
}

// SetParentID sets the "parent_id" field.
func (m *PageMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PageMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PageMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[page.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PageMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[page.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PageMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, page.FieldParentID)
}

// SetTitle sets the "title" field.
func (m *PageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PageMutation) ResetTitle() {
	m.title = nil
}

// SetFeaturedIndex sets the "featured_index" field.
func (m *PageMutation) SetFeaturedIndex(i int8) {
	m.featured_index = &i
	m.addfeatured_index = nil
}

// FeaturedIndex returns the value of the "featured_index" field in the mutation.
func (m *PageMutation) FeaturedIndex() (r int8, exists bool) {
	v := m.featured_index
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedIndex returns the old "featured_index" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldFeaturedIndex(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedIndex: %w", err)
	}
	return oldValue.FeaturedIndex, nil
}

// AddFeaturedIndex adds i to the "featured_index" field.
func (m *PageMutation) AddFeaturedIndex(i int8) {
	if m.addfeatured_index != nil {
		*m.addfeatured_index += i
	} else {
		m.addfeatured_index = &i
	}
}

// AddedFeaturedIndex returns the value that was added to the "featured_index" field in this mutation.
func (m *PageMutation) AddedFeaturedIndex() (r int8, exists bool) {
	v := m.addfeatured_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeaturedIndex resets all changes to the "featured_index" field.
func (m *PageMutation) ResetFeaturedIndex() {
	m.featured_index = nil
	m.addfeatured_index = nil
}

// SetFeaturedContent sets the "featured_content" field.
func (m *PageMutation) SetFeaturedContent(s string) {
	m.featured_content = &s
}

// FeaturedContent returns the value of the "featured_content" field in the mutation.
func (m *PageMutation) FeaturedContent() (r string, exists bool) {
	v := m.featured_content
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedContent returns the old "featured_content" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldFeaturedContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedContent: %w", err)
	}
	return oldValue.FeaturedContent, nil
}

// ResetFeaturedContent resets all changes to the "featured_content" field.
func (m *PageMutation) ResetFeaturedContent() {
	m.featured_content = nil
}

// SetRecommend sets the "recommend" field.
func (m *PageMutation) SetRecommend(i int64) {
	m.recommend = &i
	m.addrecommend = nil
}

// Recommend returns the value of the "recommend" field in the mutation.
func (m *PageMutation) Recommend() (r int64, exists bool) {
	v := m.recommend
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommend returns the old "recommend" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldRecommend(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommend: %w", err)
	}
	return oldValue.Recommend, nil
}

// AddRecommend adds i to the "recommend" field.
func (m *PageMutation) AddRecommend(i int64) {
	if m.addrecommend != nil {
		*m.addrecommend += i
	} else {
		m.addrecommend = &i
	}
}

// AddedRecommend returns the value that was added to the "recommend" field in this mutation.
func (m *PageMutation) AddedRecommend() (r int64, exists bool) {
	v := m.addrecommend
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecommend resets all changes to the "recommend" field.
func (m *PageMutation) ResetRecommend() {
	m.recommend = nil
	m.addrecommend = nil
}

// ClearParent clears the "parent" edge to the Page entity.
func (m *PageMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Page entity was cleared.
func (m *PageMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PageMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PageMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddSubpageIDs adds the "subpages" edge to the Page entity by ids.
func (m *PageMutation) AddSubpageIDs(ids ...uuid.UUID) {
	if m.subpages == nil {
		m.subpages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subpages[ids[i]] = struct{}{}
	}
}

// ClearSubpages clears the "subpages" edge to the Page entity.
func (m *PageMutation) ClearSubpages() {
	m.clearedsubpages = true
}

// SubpagesCleared reports if the "subpages" edge to the Page entity was cleared.
func (m *PageMutation) SubpagesCleared() bool {
	return m.clearedsubpages
}

// RemoveSubpageIDs removes the "subpages" edge to the Page entity by IDs.
func (m *PageMutation) RemoveSubpageIDs(ids ...uuid.UUID) {
	if m.removedsubpages == nil {
		m.removedsubpages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subpages, ids[i])
		m.removedsubpages[ids[i]] = struct{}{}
	}
}

// RemovedSubpages returns the removed IDs of the "subpages" edge to the Page entity.
func (m *PageMutation) RemovedSubpagesIDs() (ids []uuid.UUID) {
	for id := range m.removedsubpages {
		ids = append(ids, id)
	}
	return
}

// SubpagesIDs returns the "subpages" edge IDs in the mutation.
func (m *PageMutation) SubpagesIDs() (ids []uuid.UUID) {
	for id := range m.subpages {
		ids = append(ids, id)
	}
	return
}

// ResetSubpages resets all changes to the "subpages" edge.
func (m *PageMutation) ResetSubpages() {
	m.subpages = nil
	m.clearedsubpages = false
	m.removedsubpages = nil
}

// AddTopListIDs adds the "top_lists" edge to the TopList entity by ids.
func (m *PageMutation) AddTopListIDs(ids ...uuid.UUID) {
	if m.top_lists == nil {
		m.top_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.top_lists[ids[i]] = struct{}{}
	}
}

// ClearTopLists clears the "top_lists" edge to the TopList entity.
func (m *PageMutation) ClearTopLists() {
	m.clearedtop_lists = true
}

// TopListsCleared reports if the "top_lists" edge to the TopList entity was cleared.
func (m *PageMutation) TopListsCleared() bool {
	return m.clearedtop_lists
}

// RemoveTopListIDs removes the "top_lists" edge to the TopList entity by IDs.
func (m *PageMutation) RemoveTopListIDs(ids ...uuid.UUID) {
	if m.removedtop_lists == nil {
		m.removedtop_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.top_lists, ids[i])
		m.removedtop_lists[ids[i]] = struct{}{}
	}
}

// RemovedTopLists returns the removed IDs of the "top_lists" edge to the TopList entity.
func (m *PageMutation) RemovedTopListsIDs() (ids []uuid.UUID) {
	for id := range m.removedtop_lists {
		ids = append(ids, id)
	}
	return
}

// TopListsIDs returns the "top_lists" edge IDs in the mutation.
func (m *PageMutation) TopListsIDs() (ids []uuid.UUID) {
	for id := range m.top_lists {
		ids = append(ids, id)
	}
	return
}

// ResetTopLists resets all changes to the "top_lists" edge.
func (m *PageMutation) ResetTopLists() {
	m.top_lists = nil
	m.clearedtop_lists = false
	m.removedtop_lists = nil
}

// Where appends a list predicates to the PageMutation builder.
func (m *PageMutation) Where(ps ...predicate.Page) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Page).
func (m *PageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_unix != nil {
		fields = append(fields, page.FieldCreatedUnix)
	}
	if m.updated_unix != nil {
		fields = append(fields, page.FieldUpdatedUnix)
	}
	if m.deleted_unix != nil {
		fields = append(fields, page.FieldDeletedUnix)
	}
	if m.parent != nil {
		fields = append(fields, page.FieldParentID)
	}
	if m.title != nil {
		fields = append(fields, page.FieldTitle)
	}
	if m.featured_index != nil {
		fields = append(fields, page.FieldFeaturedIndex)
	}
	if m.featured_content != nil {
		fields = append(fields, page.FieldFeaturedContent)
	}
	if m.recommend != nil {
		fields = append(fields, page.FieldRecommend)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case page.FieldCreatedUnix:
		return m.CreatedUnix()
	case page.FieldUpdatedUnix:
		return m.UpdatedUnix()
	case page.FieldDeletedUnix:
		return m.DeletedUnix()
	case page.FieldParentID:
		return m.ParentID()
	case page.FieldTitle:
		return m.Title()
	case page.FieldFeaturedIndex:
		return m.FeaturedIndex()
	case page.FieldFeaturedContent:
		return m.FeaturedContent()
	case page.FieldRecommend:
		return m.Recommend()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case page.FieldCreatedUnix:
		return m.OldCreatedUnix(ctx)
	case page.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	case page.FieldDeletedUnix:
		return m.OldDeletedUnix(ctx)
	case page.FieldParentID:
		return m.OldParentID(ctx)
	case page.FieldTitle:
		return m.OldTitle(ctx)
	case page.FieldFeaturedIndex:
		return m.OldFeaturedIndex(ctx)
	case page.FieldFeaturedContent:
		return m.OldFeaturedContent(ctx)
	case page.FieldRecommend:
		return m.OldRecommend(ctx)
	}
	return nil, fmt.Errorf("unknown Page field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case page.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedUnix(v)
		return nil
	case page.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	case page.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedUnix(v)
		return nil
	case page.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case page.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case page.FieldFeaturedIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedIndex(v)
		return nil
	case page.FieldFeaturedContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedContent(v)
		return nil
	case page.FieldRecommend:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommend(v)
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_unix != nil {
		fields = append(fields, page.FieldCreatedUnix)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, page.FieldUpdatedUnix)
	}
	if m.adddeleted_unix != nil {
		fields = append(fields, page.FieldDeletedUnix)
	}
	if m.addfeatured_index != nil {
		fields = append(fields, page.FieldFeaturedIndex)
	}
	if m.addrecommend != nil {
		fields = append(fields, page.FieldRecommend)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case page.FieldCreatedUnix:
		return m.AddedCreatedUnix()
	case page.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	case page.FieldDeletedUnix:
		return m.AddedDeletedUnix()
	case page.FieldFeaturedIndex:
		return m.AddedFeaturedIndex()
	case page.FieldRecommend:
		return m.AddedRecommend()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case page.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedUnix(v)
		return nil
	case page.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	case page.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedUnix(v)
		return nil
	case page.FieldFeaturedIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeaturedIndex(v)
		return nil
	case page.FieldRecommend:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecommend(v)
		return nil
	}
	return fmt.Errorf("unknown Page numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(page.FieldDeletedUnix) {
		fields = append(fields, page.FieldDeletedUnix)
	}
	if m.FieldCleared(page.FieldParentID) {
		fields = append(fields, page.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageMutation) ClearField(name string) error {
	switch name {
	case page.FieldDeletedUnix:
		m.ClearDeletedUnix()
		return nil
	case page.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Page nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageMutation) ResetField(name string) error {
	switch name {
	case page.FieldCreatedUnix:
		m.ResetCreatedUnix()
		return nil
	case page.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	case page.FieldDeletedUnix:
		m.ResetDeletedUnix()
		return nil
	case page.FieldParentID:
		m.ResetParentID()
		return nil
	case page.FieldTitle:
		m.ResetTitle()
		return nil
	case page.FieldFeaturedIndex:
		m.ResetFeaturedIndex()
		return nil
	case page.FieldFeaturedContent:
		m.ResetFeaturedContent()
		return nil
	case page.FieldRecommend:
		m.ResetRecommend()
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, page.EdgeParent)
	}
	if m.subpages != nil {
		edges = append(edges, page.EdgeSubpages)
	}
	if m.top_lists != nil {
		edges = append(edges, page.EdgeTopLists)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case page.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case page.EdgeSubpages:
		ids := make([]ent.Value, 0, len(m.subpages))
		for id := range m.subpages {
			ids = append(ids, id)
		}
		return ids
	case page.EdgeTopLists:
		ids := make([]ent.Value, 0, len(m.top_lists))
		for id := range m.top_lists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsubpages != nil {
		edges = append(edges, page.EdgeSubpages)
	}
	if m.removedtop_lists != nil {
		edges = append(edges, page.EdgeTopLists)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case page.EdgeSubpages:
		ids := make([]ent.Value, 0, len(m.removedsubpages))
		for id := range m.removedsubpages {
			ids = append(ids, id)
		}
		return ids
	case page.EdgeTopLists:
		ids := make([]ent.Value, 0, len(m.removedtop_lists))
		for id := range m.removedtop_lists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, page.EdgeParent)
	}
	if m.clearedsubpages {
		edges = append(edges, page.EdgeSubpages)
	}
	if m.clearedtop_lists {
		edges = append(edges, page.EdgeTopLists)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageMutation) EdgeCleared(name string) bool {
	switch name {
	case page.EdgeParent:
		return m.clearedparent
	case page.EdgeSubpages:
		return m.clearedsubpages
	case page.EdgeTopLists:
		return m.clearedtop_lists
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageMutation) ClearEdge(name string) error {
	switch name {
	case page.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Page unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageMutation) ResetEdge(name string) error {
	switch name {
	case page.EdgeParent:
		m.ResetParent()
		return nil
	case page.EdgeSubpages:
		m.ResetSubpages()
		return nil
	case page.EdgeTopLists:
		m.ResetTopLists()
		return nil
	}
	return fmt.Errorf("unknown Page edge %s", name)
}

// TopListMutation represents an operation that mutates the TopList nodes in the graph.
type TopListMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_unix       *int64
	addcreated_unix    *int64
	updated_unix       *int64
	addupdated_unix    *int64
	deleted_unix       *int64
	adddeleted_unix    *int64
	title              *string
	intro              *string
	category           *toplist.Category
	lower_banner       *toplist.LowerBanner
	top_right          *toplist.TopRight
	clearedFields      map[string]struct{}
	information        *uuid.UUID
	clearedinformation bool
	page               *uuid.UUID
	clearedpage        bool
	done               bool
	oldValue           func(context.Context) (*TopList, error)
	predicates         []predicate.TopList
}

var _ ent.Mutation = (*TopListMutation)(nil)

// toplistOption allows management of the mutation configuration using functional options.
type toplistOption func(*TopListMutation)

// newTopListMutation creates new mutation for the TopList entity.
func newTopListMutation(c config, op Op, opts ...toplistOption) *TopListMutation {
	m := &TopListMutation{
		config:        c,
		op:            op,
		typ:           TypeTopList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopListID sets the ID field of the mutation.
func withTopListID(id uuid.UUID) toplistOption {
	return func(m *TopListMutation) {
		var (
			err   error
			once  sync.Once
			value *TopList
		)
		m.oldValue = func(ctx context.Context) (*TopList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopList sets the old TopList of the mutation.
func withTopList(node *TopList) toplistOption {
	return func(m *TopListMutation) {
		m.oldValue = func(context.Context) (*TopList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopList entities.
func (m *TopListMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopListMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopListMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedUnix sets the "created_unix" field.
func (m *TopListMutation) SetCreatedUnix(i int64) {
	m.created_unix = &i
	m.addcreated_unix = nil
}

// CreatedUnix returns the value of the "created_unix" field in the mutation.
func (m *TopListMutation) CreatedUnix() (r int64, exists bool) {
	v := m.created_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedUnix returns the old "created_unix" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldCreatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedUnix: %w", err)
	}
	return oldValue.CreatedUnix, nil
}

// AddCreatedUnix adds i to the "created_unix" field.
func (m *TopListMutation) AddCreatedUnix(i int64) {
	if m.addcreated_unix != nil {
		*m.addcreated_unix += i
	} else {
		m.addcreated_unix = &i
	}
}

// AddedCreatedUnix returns the value that was added to the "created_unix" field in this mutation.
func (m *TopListMutation) AddedCreatedUnix() (r int64, exists bool) {
	v := m.addcreated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedUnix resets all changes to the "created_unix" field.
func (m *TopListMutation) ResetCreatedUnix() {
	m.created_unix = nil
	m.addcreated_unix = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *TopListMutation) SetUpdatedUnix(i int64) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *TopListMutation) UpdatedUnix() (r int64, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldUpdatedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *TopListMutation) AddUpdatedUnix(i int64) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *TopListMutation) AddedUpdatedUnix() (r int64, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *TopListMutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// SetDeletedUnix sets the "deleted_unix" field.
func (m *TopListMutation) SetDeletedUnix(i int64) {
	m.deleted_unix = &i
	m.adddeleted_unix = nil
}

// DeletedUnix returns the value of the "deleted_unix" field in the mutation.
func (m *TopListMutation) DeletedUnix() (r int64, exists bool) {
	v := m.deleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedUnix returns the old "deleted_unix" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldDeletedUnix(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedUnix: %w", err)
	}
	return oldValue.DeletedUnix, nil
}

// AddDeletedUnix adds i to the "deleted_unix" field.
func (m *TopListMutation) AddDeletedUnix(i int64) {
	if m.adddeleted_unix != nil {
		*m.adddeleted_unix += i
	} else {
		m.adddeleted_unix = &i
	}
}

// AddedDeletedUnix returns the value that was added to the "deleted_unix" field in this mutation.
func (m *TopListMutation) AddedDeletedUnix() (r int64, exists bool) {
	v := m.adddeleted_unix
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedUnix clears the value of the "deleted_unix" field.
func (m *TopListMutation) ClearDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	m.clearedFields[toplist.FieldDeletedUnix] = struct{}{}
}

// DeletedUnixCleared returns if the "deleted_unix" field was cleared in this mutation.
func (m *TopListMutation) DeletedUnixCleared() bool {
	_, ok := m.clearedFields[toplist.FieldDeletedUnix]
	return ok
}

// ResetDeletedUnix resets all changes to the "deleted_unix" field.
func (m *TopListMutation) ResetDeletedUnix() {
	m.deleted_unix = nil
	m.adddeleted_unix = nil
	delete(m.clearedFields, toplist.FieldDeletedUnix)
}

// SetInformationID sets the "information_id" field.
func (m *TopListMutation) SetInformationID(u uuid.UUID) {
	m.information = &u
}

// InformationID returns the value of the "information_id" field in the mutation.
func (m *TopListMutation) InformationID() (r uuid.UUID, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformationID returns the old "information_id" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldInformationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformationID: %w", err)
	}
	return oldValue.InformationID, nil
}

// ClearInformationID clears the value of the "information_id" field.
func (m *TopListMutation) ClearInformationID() {
	m.information = nil
	m.clearedFields[toplist.FieldInformationID] = struct{}{}
}

// InformationIDCleared returns if the "information_id" field was cleared in this mutation.
func (m *TopListMutation) InformationIDCleared() bool {
	_, ok := m.clearedFields[toplist.FieldInformationID]
	return ok
}

// ResetInformationID resets all changes to the "information_id" field.
func (m *TopListMutation) ResetInformationID() {
	m.information = nil
	delete(m.clearedFields, toplist.FieldInformationID)
}

// SetPageID sets the "page_id" field.
func (m *TopListMutation) SetPageID(u uuid.UUID) {
	m.page = &u
}

// PageID returns the value of the "page_id" field in the mutation.
func (m *TopListMutation) PageID() (r uuid.UUID, exists bool) {
	v := m.page
	if v == nil {
		return
	}
	return *v, true
}

// OldPageID returns the old "page_id" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldPageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageID: %w", err)
	}
	return oldValue.PageID, nil
}

// ClearPageID clears the value of the "page_id" field.
func (m *TopListMutation) ClearPageID() {
	m.page = nil
	m.clearedFields[toplist.FieldPageID] = struct{}{}
}

// PageIDCleared returns if the "page_id" field was cleared in this mutation.
func (m *TopListMutation) PageIDCleared() bool {
	_, ok := m.clearedFields[toplist.FieldPageID]
	return ok
}

// ResetPageID resets all changes to the "page_id" field.
func (m *TopListMutation) ResetPageID() {
	m.page = nil
	delete(m.clearedFields, toplist.FieldPageID)
}

// SetTitle sets the "title" field.
func (m *TopListMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TopListMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TopListMutation) ResetTitle() {
	m.title = nil
}

// SetIntro sets the "intro" field.
func (m *TopListMutation) SetIntro(s string) {
	m.intro = &s
}

// Intro returns the value of the "intro" field in the mutation.
func (m *TopListMutation) Intro() (r string, exists bool) {
	v := m.intro
	if v == nil {
		return
	}
	return *v, true
}

// OldIntro returns the old "intro" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldIntro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntro: %w", err)
	}
	return oldValue.Intro, nil
}

// ResetIntro resets all changes to the "intro" field.
func (m *TopListMutation) ResetIntro() {
	m.intro = nil
}

// SetCategory sets the "category" field.
func (m *TopListMutation) SetCategory(t toplist.Category) {
	m.category = &t
}

// Category returns the value of the "category" field in the mutation.
func (m *TopListMutation) Category() (r toplist.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldCategory(ctx context.Context) (v toplist.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TopListMutation) ResetCategory() {
	m.category = nil
}

// SetLowerBanner sets the "lower_banner" field.
func (m *TopListMutation) SetLowerBanner(tb toplist.LowerBanner) {
	m.lower_banner = &tb
}

// LowerBanner returns the value of the "lower_banner" field in the mutation.
func (m *TopListMutation) LowerBanner() (r toplist.LowerBanner, exists bool) {
	v := m.lower_banner
	if v == nil {
		return
	}
	return *v, true
}

// OldLowerBanner returns the old "lower_banner" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldLowerBanner(ctx context.Context) (v toplist.LowerBanner, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowerBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowerBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowerBanner: %w", err)
	}
	return oldValue.LowerBanner, nil
}

// ResetLowerBanner resets all changes to the "lower_banner" field.
func (m *TopListMutation) ResetLowerBanner() {
	m.lower_banner = nil
}

// SetTopRight sets the "top_right" field.
func (m *TopListMutation) SetTopRight(tr toplist.TopRight) {
	m.top_right = &tr
}

// TopRight returns the value of the "top_right" field in the mutation.
func (m *TopListMutation) TopRight() (r toplist.TopRight, exists bool) {
	v := m.top_right
	if v == nil {
		return
	}
	return *v, true
}

// OldTopRight returns the old "top_right" field's value of the TopList entity.
// If the TopList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopListMutation) OldTopRight(ctx context.Context) (v toplist.TopRight, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopRight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopRight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopRight: %w", err)
	}
	return oldValue.TopRight, nil
}

// ResetTopRight resets all changes to the "top_right" field.
func (m *TopListMutation) ResetTopRight() {
	m.top_right = nil
}

// ClearInformation clears the "information" edge to the InformationV1 entity.
func (m *TopListMutation) ClearInformation() {
	m.clearedinformation = true
}

// InformationCleared reports if the "information" edge to the InformationV1 entity was cleared.
func (m *TopListMutation) InformationCleared() bool {
	return m.InformationIDCleared() || m.clearedinformation
}

// InformationIDs returns the "information" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InformationID instead. It exists only for internal usage by the builders.
func (m *TopListMutation) InformationIDs() (ids []uuid.UUID) {
	if id := m.information; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInformation resets all changes to the "information" edge.
func (m *TopListMutation) ResetInformation() {
	m.information = nil
	m.clearedinformation = false
}

// ClearPage clears the "page" edge to the Page entity.
func (m *TopListMutation) ClearPage() {
	m.clearedpage = true
}

// PageCleared reports if the "page" edge to the Page entity was cleared.
func (m *TopListMutation) PageCleared() bool {
	return m.PageIDCleared() || m.clearedpage
}

// PageIDs returns the "page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageID instead. It exists only for internal usage by the builders.
func (m *TopListMutation) PageIDs() (ids []uuid.UUID) {
	if id := m.page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPage resets all changes to the "page" edge.
func (m *TopListMutation) ResetPage() {
	m.page = nil
	m.clearedpage = false
}

// Where appends a list predicates to the TopListMutation builder.
func (m *TopListMutation) Where(ps ...predicate.TopList) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TopListMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TopList).
func (m *TopListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopListMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_unix != nil {
		fields = append(fields, toplist.FieldCreatedUnix)
	}
	if m.updated_unix != nil {
		fields = append(fields, toplist.FieldUpdatedUnix)
	}
	if m.deleted_unix != nil {
		fields = append(fields, toplist.FieldDeletedUnix)
	}
	if m.information != nil {
		fields = append(fields, toplist.FieldInformationID)
	}
	if m.page != nil {
		fields = append(fields, toplist.FieldPageID)
	}
	if m.title != nil {
		fields = append(fields, toplist.FieldTitle)
	}
	if m.intro != nil {
		fields = append(fields, toplist.FieldIntro)
	}
	if m.category != nil {
		fields = append(fields, toplist.FieldCategory)
	}
	if m.lower_banner != nil {
		fields = append(fields, toplist.FieldLowerBanner)
	}
	if m.top_right != nil {
		fields = append(fields, toplist.FieldTopRight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toplist.FieldCreatedUnix:
		return m.CreatedUnix()
	case toplist.FieldUpdatedUnix:
		return m.UpdatedUnix()
	case toplist.FieldDeletedUnix:
		return m.DeletedUnix()
	case toplist.FieldInformationID:
		return m.InformationID()
	case toplist.FieldPageID:
		return m.PageID()
	case toplist.FieldTitle:
		return m.Title()
	case toplist.FieldIntro:
		return m.Intro()
	case toplist.FieldCategory:
		return m.Category()
	case toplist.FieldLowerBanner:
		return m.LowerBanner()
	case toplist.FieldTopRight:
		return m.TopRight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toplist.FieldCreatedUnix:
		return m.OldCreatedUnix(ctx)
	case toplist.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	case toplist.FieldDeletedUnix:
		return m.OldDeletedUnix(ctx)
	case toplist.FieldInformationID:
		return m.OldInformationID(ctx)
	case toplist.FieldPageID:
		return m.OldPageID(ctx)
	case toplist.FieldTitle:
		return m.OldTitle(ctx)
	case toplist.FieldIntro:
		return m.OldIntro(ctx)
	case toplist.FieldCategory:
		return m.OldCategory(ctx)
	case toplist.FieldLowerBanner:
		return m.OldLowerBanner(ctx)
	case toplist.FieldTopRight:
		return m.OldTopRight(ctx)
	}
	return nil, fmt.Errorf("unknown TopList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toplist.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedUnix(v)
		return nil
	case toplist.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	case toplist.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedUnix(v)
		return nil
	case toplist.FieldInformationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformationID(v)
		return nil
	case toplist.FieldPageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageID(v)
		return nil
	case toplist.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case toplist.FieldIntro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntro(v)
		return nil
	case toplist.FieldCategory:
		v, ok := value.(toplist.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case toplist.FieldLowerBanner:
		v, ok := value.(toplist.LowerBanner)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowerBanner(v)
		return nil
	case toplist.FieldTopRight:
		v, ok := value.(toplist.TopRight)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopRight(v)
		return nil
	}
	return fmt.Errorf("unknown TopList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopListMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_unix != nil {
		fields = append(fields, toplist.FieldCreatedUnix)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, toplist.FieldUpdatedUnix)
	}
	if m.adddeleted_unix != nil {
		fields = append(fields, toplist.FieldDeletedUnix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopListMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case toplist.FieldCreatedUnix:
		return m.AddedCreatedUnix()
	case toplist.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	case toplist.FieldDeletedUnix:
		return m.AddedDeletedUnix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopListMutation) AddField(name string, value ent.Value) error {
	switch name {
	case toplist.FieldCreatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedUnix(v)
		return nil
	case toplist.FieldUpdatedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	case toplist.FieldDeletedUnix:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedUnix(v)
		return nil
	}
	return fmt.Errorf("unknown TopList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopListMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toplist.FieldDeletedUnix) {
		fields = append(fields, toplist.FieldDeletedUnix)
	}
	if m.FieldCleared(toplist.FieldInformationID) {
		fields = append(fields, toplist.FieldInformationID)
	}
	if m.FieldCleared(toplist.FieldPageID) {
		fields = append(fields, toplist.FieldPageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopListMutation) ClearField(name string) error {
	switch name {
	case toplist.FieldDeletedUnix:
		m.ClearDeletedUnix()
		return nil
	case toplist.FieldInformationID:
		m.ClearInformationID()
		return nil
	case toplist.FieldPageID:
		m.ClearPageID()
		return nil
	}
	return fmt.Errorf("unknown TopList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopListMutation) ResetField(name string) error {
	switch name {
	case toplist.FieldCreatedUnix:
		m.ResetCreatedUnix()
		return nil
	case toplist.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	case toplist.FieldDeletedUnix:
		m.ResetDeletedUnix()
		return nil
	case toplist.FieldInformationID:
		m.ResetInformationID()
		return nil
	case toplist.FieldPageID:
		m.ResetPageID()
		return nil
	case toplist.FieldTitle:
		m.ResetTitle()
		return nil
	case toplist.FieldIntro:
		m.ResetIntro()
		return nil
	case toplist.FieldCategory:
		m.ResetCategory()
		return nil
	case toplist.FieldLowerBanner:
		m.ResetLowerBanner()
		return nil
	case toplist.FieldTopRight:
		m.ResetTopRight()
		return nil
	}
	return fmt.Errorf("unknown TopList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopListMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.information != nil {
		edges = append(edges, toplist.EdgeInformation)
	}
	if m.page != nil {
		edges = append(edges, toplist.EdgePage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toplist.EdgeInformation:
		if id := m.information; id != nil {
			return []ent.Value{*id}
		}
	case toplist.EdgePage:
		if id := m.page; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinformation {
		edges = append(edges, toplist.EdgeInformation)
	}
	if m.clearedpage {
		edges = append(edges, toplist.EdgePage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopListMutation) EdgeCleared(name string) bool {
	switch name {
	case toplist.EdgeInformation:
		return m.clearedinformation
	case toplist.EdgePage:
		return m.clearedpage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopListMutation) ClearEdge(name string) error {
	switch name {
	case toplist.EdgeInformation:
		m.ClearInformation()
		return nil
	case toplist.EdgePage:
		m.ClearPage()
		return nil
	}
	return fmt.Errorf("unknown TopList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopListMutation) ResetEdge(name string) error {
	switch name {
	case toplist.EdgeInformation:
		m.ResetInformation()
		return nil
	case toplist.EdgePage:
		m.ResetPage()
		return nil
	}
	return fmt.Errorf("unknown TopList edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Current      *int
	add_Current   *int
	_Last         *int
	add_Last      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Version, error)
	predicates    []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id int) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("media: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCurrent sets the "Current" field.
func (m *VersionMutation) SetCurrent(i int) {
	m._Current = &i
	m.add_Current = nil
}

// Current returns the value of the "Current" field in the mutation.
func (m *VersionMutation) Current() (r int, exists bool) {
	v := m._Current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "Current" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCurrent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// AddCurrent adds i to the "Current" field.
func (m *VersionMutation) AddCurrent(i int) {
	if m.add_Current != nil {
		*m.add_Current += i
	} else {
		m.add_Current = &i
	}
}

// AddedCurrent returns the value that was added to the "Current" field in this mutation.
func (m *VersionMutation) AddedCurrent() (r int, exists bool) {
	v := m.add_Current
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrent resets all changes to the "Current" field.
func (m *VersionMutation) ResetCurrent() {
	m._Current = nil
	m.add_Current = nil
}

// SetLast sets the "Last" field.
func (m *VersionMutation) SetLast(i int) {
	m._Last = &i
	m.add_Last = nil
}

// Last returns the value of the "Last" field in the mutation.
func (m *VersionMutation) Last() (r int, exists bool) {
	v := m._Last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "Last" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldLast(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// AddLast adds i to the "Last" field.
func (m *VersionMutation) AddLast(i int) {
	if m.add_Last != nil {
		*m.add_Last += i
	} else {
		m.add_Last = &i
	}
}

// AddedLast returns the value that was added to the "Last" field in this mutation.
func (m *VersionMutation) AddedLast() (r int, exists bool) {
	v := m.add_Last
	if v == nil {
		return
	}
	return *v, true
}

// ResetLast resets all changes to the "Last" field.
func (m *VersionMutation) ResetLast() {
	m._Last = nil
	m.add_Last = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Current != nil {
		fields = append(fields, version.FieldCurrent)
	}
	if m._Last != nil {
		fields = append(fields, version.FieldLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCurrent:
		return m.Current()
	case version.FieldLast:
		return m.Last()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldCurrent:
		return m.OldCurrent(ctx)
	case version.FieldLast:
		return m.OldLast(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldCurrent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case version.FieldLast:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.add_Current != nil {
		fields = append(fields, version.FieldCurrent)
	}
	if m.add_Last != nil {
		fields = append(fields, version.FieldLast)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCurrent:
		return m.AddedCurrent()
	case version.FieldLast:
		return m.AddedLast()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldCurrent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrent(v)
		return nil
	case version.FieldLast:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLast(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldCurrent:
		m.ResetCurrent()
		return nil
	case version.FieldLast:
		m.ResetLast()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Version edge %s", name)
}
